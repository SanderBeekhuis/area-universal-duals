<!DOCTYPE html>
<html >
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.23">
<style type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.footnotetext{margin:0ex; padding:0ex;}
div.footnotetext P{margin:0px; text-indent:1em;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.titlemain{margin:1ex 2ex 2ex 1ex;}
.titlerest{margin:0ex 2ex;}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
div table{margin-left:inherit;margin-right:inherit;margin-bottom:2px;margin-top:2px}
td table{margin:auto;}
table{border-collapse:collapse;}
td{padding:0;}
.cellpadding0 tr td{padding:0;}
.cellpadding1 tr td{padding:1px;}
pre{text-align:left;margin-left:0ex;margin-right:auto;}
blockquote{margin-left:4ex;margin-right:4ex;text-align:left;}
td p{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
</style>
<title>thesis</title>
</head>
<body >
<!--HEVEA command line is: /usr/bin/hevea thesis.tex -->
<!--CUT STYLE article--><!--CUT DEF section 1 --><div class="center">
<img src="thesis001.png"><br>
<span style="font-size:large">Department of Mathematics and Computer Science <br>
Applied Geometric Algorithms Research Group</span><p><span style="font-size:large"><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
</span></p><p><span style="font-size:large">




</span><span style="font-size:large">115</span><span style="font-size:large">(52,89)

</span><span style="font-size:xx-large"><span style="font-weight:bold">On </span></span><span style="font-size:xx-large"><span style="font-weight:bold"><span style="font-style:italic">k</span></span></span><span style="font-size:xx-large"><span style="font-weight:bold">-Sided Rectangular Duals<br>
</span></span><span style="font-size:xx-large">
<span style="font-size:x-large"><br>
<br>
<br>

S. J. Beekhuis<br>
 <br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
</span></span></p><p><span style="font-size:x-large"><img src="thesis002.png"></span></p><p><span style="font-size:large"><br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
</span></p><div class="minipage"><span style="font-size:large">
Supervisors:<br>
</span><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:left;white-space:nowrap" ><span style="font-size:large"> prof. dr. B. Speckmann</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-size:large"> dr. K. A. B. Verbeek</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-size:large"> dr. J. Nederlof</span></td></tr>
<tr><td style="text-align:left;white-space:nowrap" ><span style="font-size:large"> dr. R. A. Pendavingh</span></td></tr>
</table><span style="font-size:large">
</span></div><p><span style="font-size:large">Eindhoven,  March 9, 2017<br>

</span><a href="mailto:sander@sanderbeekhuis.nl"><span style="font-size:large"><span style="font-family:monospace">sandersanderbeekhuis.nl</span></span></a></p></div><!--TOC section id="sec1" Abstract-->
<h2 id="sec1" class="section">Abstract</h2><!--SEC END --><p>A <em>rectangular layout</em> (or simply <em>layout</em>) <span style="color:red"><span style="font-style:italic">L</span></span> is a partition of a rectangle into a finite set of interior-disjoint rectangles. Rectangular layouts have many applications, for example as rectangular cartograms in cartography, chip designs in VLSI and floorplans in architecture. A rectangular cartogram is a map in which the regions are replaced by scaled rectangles representing some quantity.</p><p>In the rectangular cartogram application it is desirable to find a layout that always keeps the same adjacencies between the interior rectangles when their sizes change. For example, when displaying a cartogram of a single quantity at different points in time, we prefer to do this using a set of layouts with the same adjacencies. Such layouts are <em>area-universal</em>.</p><p>The interior of a rectangular layout contains vertical and horizontal line segments.
Any line segment that can not extend farther on either side is a <em>maximal segment</em>.
A rectangular layout is <span style="font-style:italic">k</span><em>-sided</em> if every maximal segment has at most <span style="font-style:italic">k</span> rectangles on one of its sides.
A <em>rectangular dual</em> of a graph <span style="font-style:italic">G</span> is a rectangular layout whose adjacencies are the same as those of <span style="font-style:italic">G</span>.
A necessary and sufficient condition for a layout to be area-universal is that it is <em>one-sided</em>, that is <span style="font-style:italic">k</span>-sided with <span style="font-style:italic">k</span>=1.
Unfortunately, not all graphs with a rectangular dual have a one-sided dual.</p><p>For graphs without a one-sided dual, a <span style="font-style:italic">k</span>-sided dual with <span style="font-style:italic">k</span> as small as possible is often a dual that has the smallest risk of adjacencies changing when changing the size of the interior rectangles.</p><p>In this thesis we prove that we can not find a <span style="font-style:italic">k</span>-sided rectangular dual for all graphs admitting a rectangular dual, no matter the constant <span style="font-style:italic">k</span>.
However, for certain graphs, namely those without separating 4-cycles, this might be possible.
We do not quite obtain this result. Instead, we present an algorithm giving a <span style="font-style:italic">d</span>−1-sided dual, with <span style="font-style:italic">d</span> the maximal degree of the vertices of <span style="font-style:italic">G</span> in Ḡ, a so-called corner assignment.
</p><!--TOC section id="sec2" Contents-->
<h2 id="sec2" class="section">Contents</h2><!--SEC END --><ul class="toc"><li class="li-toc">
<a href="#sec3">1  Introduction</a>
</li></ul>
<!--TOC section id="sec3" Introduction-->
<h2 id="sec3" class="section">1  Introduction</h2><!--SEC END --><p><span style="font-weight:bold">Motivation.</span>
In for example atlases, <em>rectangular cartograms</em> are used to display information, such as population or economic strength, in a spatial manner.
In a rectangular cartogram the geographic regions of an ordinary map are replaced by rectangles; we let these rectangles maintain adjacencies with each other to suggest geographic location and scale them proportionally to the quantities they represent.
Raisz [<a href="#Raisz1934"></a>] introduced these cartograms and provided cartograms of, for instance, land area, population (see Figure <a href="#fig%3Aintro%3Araisz">??</a>) and wealth of the United States of America.
In a rectangular cartogram it is preferable to maintain the adjacencies of the regions that are replaced by rectangles, this in order to keep the representation recognizable.
However, this is only possible under certain conditions that will be given later in this chapter.
The cartograms made by Raisz do not keep all adjacencies. For example, Florida and Alabama are not adjacent in Figure <a href="#fig%3Aintro%3Araisz">??</a> while they are in reality.</p><p>The value of the displayed quantities, like population or wealth, often changes over time.
When we draw a set of cartograms displaying a single quantity at different moments in time, it is desirable that the adjacencies between the rectangles in these cartograms remain the same, no matter the moment in time.
Moreover, it would be even better if the nature of these adjacencies, that is whether the rectangles border in a vertical or horizontal manner, does not change.
This raises the question: When is this possible?</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
<img src="thesis003.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 1: A cartogram by Raisz [<a href="#Raisz1934"></a>] made in 1934.</td></tr>
</table></div>
<a id="fig:intro:raisz"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><p>
r7cm <img src="thesis004.png">
Three area-universal layouts.
<a id="fig:intro:areaunivLayout"></a>

<span style="font-weight:bold">Rectangular layout.</span>
Mathematically, a rectangular cartogram is a <em>rectangular layout</em> (or simply <em>layout</em>).
A layout <span style="color:red"><span style="font-style:italic">L</span></span> is a partition of an axis-parallel rectangle into a finite set of interior-disjoint axis-parallel rectangles.
Roughly speaking, we say that two rectangular layouts are <em>combinatorially equivalent</em> (or simply <em>equivalent</em>) when they have the same adjacencies and these adjacencies are in the same manner, that is horizontal or vertical. We will later, in Section <a href="#s%3Arel">??</a>, define this more thoroughly.
A rectangular layout is <em>area-universal</em> when it has a combinatorially equivalent layout, regardless the area sizes we assign to each rectangle.
Three area-universal equivalent layouts are given in Figure <a href="#fig%3Aintro%3AareaunivLayout">??</a>.</p><p>The question above then becomes: For which maps can we create area-universal layouts?
Clearly not those maps that do not have any corresponding layouts with the same adjacencies. However, it will turn out there are more maps without a corresponding area-universal layout.</p><p>[8]r7cm
<img src="thesis005.png">
A graph with two non-equivalent duals.
<a id="fig:intro:nonuniqueRectDual"></a>
</p><p><span style="font-weight:bold">Adjacency graphs.</span>
We can represent the adjacencies of map regions by an <em>adjacency graph</em> <span style="font-style:italic">G</span> where each region is represented by a vertex and two vertices are connected by an edge exactly when their regions are adjacent.
Similarly, in the <em>adjacency graph</em> <span style="color:red"><span style="font-style:italic">G</span></span>(<span style="color:red"><span style="font-style:italic">L</span></span>) of a rectangular layout <span style="color:red"><span style="font-style:italic">L</span></span> each rectangle is represented by a vertex and two vertices are connected by an edge exactly when their rectangles are adjacent.
A layout <span style="color:red"><span style="font-style:italic">L</span></span> is a <em>rectangular dual</em> of a graph <span style="font-style:italic">G</span> if we have that <span style="font-style:italic">G</span> = <span style="color:red"><span style="font-style:italic">G</span></span>(<span style="color:red"><span style="font-style:italic">L</span></span>).
In general, a single graph can have multiple non-equivalent rectangular duals. An example of this is the graph in Figure <a href="#fig%3Aintro%3AnonuniqueRectDual">??</a>.</p><p>Rinsma found a graph in [<a href="#Rinsma1987"></a>], displayed in Figure <a href="#fig%3Aintro%3Arinsma">??</a>, that has no area-universal rectangular duals.
That is, all rectangular layouts with this graph as adjacency graph are not area-universal.</p><p>[14]r5.5cm <img src="thesis006.png">
The graph by Rinsma [<a href="#Rinsma1987"></a>] that is not one-sided.
<a id="fig:intro:rinsma"></a>
</p><p><span style="font-weight:bold">One-sided layouts.</span>
So, unfortunately not all graphs admit area-universal duals.
We would like to know which graphs do.
Before we can state this, we need to define one-sided layouts.
Note that the interior of a rectangular layout contains vertical and horizontal line segments.
Any line segment that can not extend any farther on either side is a <em>maximal segment</em>.
A rectangular layout is <em>one-sided</em> if every maximal segment has only one rectangle on one of its sides.
The layouts in Figure <a href="#fig%3Aintro%3AareaunivLayout">??</a> and <a href="#fig%3Aintro%3AnonuniqueRectDual">??</a> are all one-sided.</p><p>In [<a href="#Eppstein2012"></a>] Eppstein et al. show that rectangular layouts are area-universal exactly when they are one-sided.
So, Rinsma’s result also implies that not every adjacency graph of a map can be represented by a one-sided layout.</p><p><span style="font-weight:bold"><span style="font-style:italic">k</span></span><span style="font-weight:bold">-sided layouts.</span>
</p><blockquote class="figure"><div class="center"><hr style="width:80%;height:2"></div>
  <div class="center">[b]0.45 @percent
<img src="thesis007.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 2: Before resizing <span style="font-style:italic">a</span></td></tr>
</table></div>
<a id="fig:intro:2sidedBefore"></a>
</div>
<div class="center">[b]0.45 @percent
<img src="thesis008.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 3: After resizing <span style="font-style:italic">a</span></td></tr>
</table></div>
<a id="fig:intro:2sidedAfter"></a>
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 4: A 2-sided segment</td></tr>
</table></div>
<a id="fig:intor:2sided"></a>
  <p>  [b]0.45 @percent
<img src="thesis009.png">
</p><div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 5: Before resizing <span style="font-style:italic">a</span></td></tr>
</table></div><p>
<a id="fig:intro:10sidedBefore"></a>

[b]0.45 @percent
<img src="thesis010.png">
</p><div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 6: After resizing <span style="font-style:italic">a</span></td></tr>
</table></div><p>
<a id="fig:intro:10sidedAfter"></a>

  </p><div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 7: A 10-sided segment</td></tr>
</table></div><p>
<a id="fig:intro:10sided"></a>
</p><div class="center"><hr style="width:80%;height:2"></div></blockquote><p>
Let us consider those graphs that do not admit any one-sided, and thus area-universal, dual as rectangular dual.
Since any dual for such a graph is not area-universal, it is inevitable that adjacencies between rectangles in this dual change when we resize them.
For these graphs we want to find layouts that have the least number of adjacency changes when area sizes change.
This is beneficial for, for example, applications displaying cartograms on a continuous timescale.
Since every time the adjacencies of the layout change, we have to compute a different rectangular layout with the right adjacencies, providing the user a rougher viewing experience.</p><p>We call a layout <span style="font-style:italic">k</span><em>-sided</em> if <span style="font-style:italic">k</span> is the smallest integer such that every maximal segment has at most <span style="font-style:italic">k</span> rectangles on one of its sides. This is a direct generalization of one-sidedness.
This generalization is useful because, when changing the areas of rectangles in a <span style="font-style:italic">k</span>-sided layout fewer adjacencies change, in general, if <span style="font-style:italic">k</span> is small then if <span style="font-style:italic">k</span> is large.</p><p>We illustrate this by comparing a typical 2-sided and a typical 10-sided segment.
Let us first consider the 2-sided segment in Figure <a href="#fig%3Aintro%3A2sidedBefore">??</a>, if the size of <span style="font-style:italic">a</span> doubles only two adjacencies change, namely <span style="font-style:italic">dA</span> disappears and <span style="font-style:italic">cB</span> appears, as can be seen in Figure <a href="#fig%3Aintro%3A2sidedAfter">??</a>.
While for a typical 10-sided segment doubling the size of <span style="font-style:italic">a</span> leads to 15 changed adjacencies, namely <span style="font-style:italic">aC</span> <span style="font-style:italic">aD</span>  <span style="font-style:italic">bB</span>  <span style="font-style:italic">bC</span>  <span style="font-style:italic">bD</span>  <span style="font-style:italic">bE</span>  <span style="font-style:italic">cC</span>  <span style="font-style:italic">cD</span>  <span style="font-style:italic">cE</span>  <span style="font-style:italic">cF</span>  <span style="font-style:italic">dE</span>  <span style="font-style:italic">dG</span>  <span style="font-style:italic">eF</span>  <span style="font-style:italic">eH</span>  <span style="font-style:italic">fG</span>, as can be seen in Figure <a href="#fig%3Aintro%3A10sided">??</a>.
Hence we would like to find <span style="font-style:italic">k</span>-sided layouts for all graphs with <span style="font-style:italic">k</span> as small as possible.</p><p><span style="font-weight:bold">Counterexample.</span>
In this thesis we provide two results on <span style="font-style:italic">k</span>-sidedness. The first result is the existence of a family of graphs <span style="font-style:italic">G</span><sub><span style="font-style:italic">k</span></sub> that, for any constant <span style="font-style:italic">k</span> ∈ ℕ, has members that are not <span style="font-style:italic">k</span>-sided (Theorem <a href="#fix%3Ath%3Afamily">??</a>). The family of graphs in this result is characterized by the occurrence of nested separating 4-cycles.
A 4<em>-cycle</em> is a cycle of length 4.
Such a cycle is separating if there are vertices in both its interior and exterior.
Separating 4-cycles are <em>nested</em> if one is contained in the other, but some of their vertices overlap. These different types of 4-cycles are demonstrated in Figure <a href="#fig%3Aintro%3A4cycle">??</a>.</p><p>r7cm
[t]2cm
<img src="thesis011.png">
A 4-cycle.

 
[t]2cm
<img src="thesis012.png">
A separating 4-cycle.

 
[t]2cm
<img src="thesis013.png">
A nested separating 4-cycle.


<a id="fig:intro:4cycle"></a>
</p><p>Separating 4-cycles in general are difficult to treat when trying to create a <span style="font-style:italic">k</span>-sided layout.
But examples found during our research seem to indicate that, in particular, nested 4-cycles are the most difficult to treat.
Finding <span style="font-style:italic">k</span>-sided rectangular duals is not the only problem that has difficulty with separating 4-cycles.</p><p>Yeap and Sarrafzadeh [<a href="#Yeap1995"></a>] investigated the problem of finding a <em>sliceable</em> dual for a graph. A rectangular layout is sliceable when it is either a single rectangle or when it has a single maximal segment which splits the layout into two sliceable layouts.
Yeap and Sarrafzadeh were able to show that all graphs without a separating 4-cycle have a sliceable rectangular dual.
They were unable to gain traction on graphs with a separating 4-cycle (in their words this is a complex cycle of length 4).</p><p>[12]r7cm
[t]3cm
<img src="thesis014.png">
Graph with separating 4-cycle.

 
[t]3cm
<img src="thesis015.png">
Corresponding area-universal dual.


<a id="fig:intro:areauniv"></a>
</p><p>Nevertheless, not all problems are intractable on graphs with a separating 4-cycle.
The problem of finding an area-universal rectangular dual of a graph, already mentioned above, was investigated by Eppstein et al. in [<a href="#Eppstein2012"></a>].
They managed to find such a rectangular dual, when it exists, for any graph <span style="font-style:italic">G</span>.
This result does affect graphs containing separating 4-cycles since there are such graphs that admit area-universal duals, as can be seen in Figure <a href="#fig%3Aintro%3Aareauniv">??</a>.</p><p>[]r8cm
[t]1.3cm
<img src="thesis016.png">
A graph <span style="font-style:italic">G</span>.
 
[t]3cm
<img src="thesis017.png">
A corner assignment of <span style="font-style:italic">G</span>.
 
[t]3cm
<img src="thesis018.png">
A rectangular dual corresponding to this corner assignment.


<a id="fig:intro:cornerAssign"></a>
</p><p><span style="font-weight:bold">Corner assignments.</span>
Before we can state the second result of this thesis, we first introduce the concept of corner assignments.
A corner assignment Ḡ of a graph <span style="font-style:italic">G</span> is an augmentation of <span style="font-style:italic">G</span> with 4 external vertices, which we call its <em>poles</em>, with the following three properties (i) every interior face has degree 3, (ii) the exterior face has degree 4 and (iii) Ḡ has no separating triangles.
A corner assignment fixes which rectangles are in the corners of the rectangular dual <span style="color:red"><span style="font-style:italic">L</span></span>, namely those adjacent to two poles, which explains the terminology. In Figure <a href="#fig%3Aintro%3AcornerAssign">??</a> we see a graph, a possible corner assignment of this graph, and a possible rectangular dual (in this case, up to equivalence, the only possible dual) of this corner assignment.</p><p><span style="font-weight:bold">Existence of rectangular duals.</span>
Now we have formulated corner assignments we can also state which graphs admit rectangular duals.
A graph admits a rectangular dual if and only if it admits a corner assignment.
This was shown independently by Kozminski and Kinnen [<a href="#Kozminski1984"></a>] and Ungar [<a href="#Ungar1953"></a>].</p><p><span style="font-weight:bold">Algorithm.</span>
After finding the counterexample, we focused our efforts on obtaining an algorithm that would provide a <span style="font-style:italic">k</span>-sided layout for corner assignments without a separating 4-cycle, for some constant <span style="font-style:italic">k</span> ∈ ℕ.
Unfortunately, we fell short of this goal and only found an algorithm that provides a <span style="font-style:italic">d</span>−1-sided layout, where <span style="font-style:italic">d</span> is the maximal degree of the vertices of <span style="font-style:italic">G</span> in the corner assignment Ḡ (Theorem <a href="#th%3Adsided">??</a>).</p><p>[14]r4.6cm <img src="thesis019.png">
A 2-sided dual of the Rinsma graph in Figure <a href="#fig%3Aintro%3Arinsma">??</a>.
<a id="fig:intro:rinsma2Sided"></a>
</p><p>That being said, during our research we did not find any graphs without separating 4-cycles that did not admit any 2-sided layouts.
For example, the graph, by Rinsma, without a one-sided dual does have a 2-sided dual, as can be seen in Figure <a href="#fig%3Aintro%3Arinsma2Sided">??</a>.
We thus conjecture that these graphs admit a 2-sided layout and it is just the algorithm for finding them that eludes us.</p><p>Its worthy of note, that the bound obtained by the algorithm is not stronger than the bound provided by the counterexample. That is, there might be an algorithm providing <span style="font-style:italic">O</span>(<span style="font-style:italic">d</span>)-sided layouts for all graphs <span style="font-style:italic">G</span> admitting a rectangular dual.</p><p><span style="font-weight:bold">Overview.</span>
The rest of this thesis is focused on obtaining these two results.
In order to do this we give extensive definitions on graphs, paths and cycles in Section <a href="#s%3Aprelim">??</a>. In Section <a href="#s%3Arel">??</a> we introduce the notion of regular edge labellings. A regular edge labeling is a way of coloring and orienting the edges of a graph that corresponds to a rectangular dual of that graph.
We frequently use this notion in the rest of this thesis.
Once we have these preliminaries out of the way, we prove Theorem <a href="#fix%3Ath%3Afamily">??</a> in Section <a href="#s%3Afix">??</a> and Theorem <a href="#th%3Adsided">??</a> in Section <a href="#s%3Aalgo">??</a>. We prove Theorem <a href="#fix%3Ath%3Afamily">??</a> by counterexample and Theorem <a href="#th%3Adsided">??</a> by giving a constructive algorithm.
</p>
<!--TOC section id="sec4" Preliminaries-->
<h2 id="sec4" class="section">2  Preliminaries</h2><!--SEC END --><p>

<a id="s:prelim"></a></p><p>Before we continue with the rest of thesis we will in this section first define some basic definitions for graphs, paths and cycles.</p><p><span style="font-weight:bold">Graphs.</span>
A <em>graph</em> <span style="font-style:italic">G</span> is an abstraction of a network. The objects are represented by a set of <em>vertices</em>.
Connections between objects are represented by a set of <em>edges</em>; each edge connects two vertices.
Two distinct edges do not have the same vertices and no edge starts and ends at the same vertex.
That is, all graphs in this thesis are <em>simple</em>.
An edge is <em>incident</em> to a vertex <span style="font-style:italic">v</span> if that edge connects <span style="font-style:italic">v</span> to another vertex.
The <em>degree</em> of a vertex is the number of edges incident to this vertex.
All graphs in this thesis are <em>planar</em>.
That is, they can be embedded in the plane without their edges crossing. A <em>face</em> is connected component of the maximal subset of the plane that is disjoint from the embedded graph. The <em>degree</em> of a face is the number of vertices on its boundary.
A face of degree 3 is a <em>triangular</em> face. The <em>outer face</em> of a graph is the one and only unbounded face.
A vertex is <em>incident</em> to a face when it lies on its boundary.</p><p>Vertices bordering the outer face are <em>outer vertices</em> while all other vertices are <em>interior vertices</em>.</p><p><span style="font-weight:bold">Angular order.</span>
For a fixed embedding of <span style="font-style:italic">G</span> the <em>angular order</em> at a vertex <span style="font-style:italic">v</span> is the clockwise order of the edges incident to <span style="font-style:italic">v</span>. We identify these edges with their other endpoints.
Two vertices <span style="font-style:italic">x</span>, <span style="font-style:italic">y</span> are said to be <em>consecutive</em> in the angular order at <span style="font-style:italic">v</span> when the edges <span style="font-style:italic">vx</span> and <span style="font-style:italic">vy</span> are consecutive in the angular order.</p><p><span style="font-weight:bold">Paths.</span>
A path <span style="color:red"><span style="font-style:italic">P</span></span> is a sequence of vertices such that every two consecutive vertices are connected by an edge. The first and last vertex of the path are its <em>extreme</em> vertices while the rest are <em>internal</em> vertices of this path. The <em>length</em> of a path is the number of edges used to connect the vertices. That, is one less than the number of vertices. In this thesis all paths are <em>simple</em>, that is, no vertex occurs twice in the path except possibly the extreme vertices.</p><p><span style="font-weight:bold">Cycles.</span>
A cycle is a path whose extreme vertices coincide. Because a cycle is a path the start and end vertex are the only vertices that occurs more than once. We call a cycle of length <span style="font-style:italic">k</span> a <span style="font-style:italic">k</span><em>-cycle</em>. A <em>triangle</em> is cycle of length 3 (i.e. a 3-cycle). By Jordan’s curve theorem a cycle splits the plane into two parts, one bounded and one unbounded. We call the bounded part the <em>interior</em> of this cycle and the unbounded part the <em>exterior</em> of this cycle.
Furthermore, the cycle of all vertices bordering the outer face is the <em>outer cycle</em>.
We call a cycle <em>separating</em> if there are vertices in both its interior and exterior.
An <em>interior edge</em> of a cycle is then an edge contained in the interior of the cycle.
An <em>interior path</em> is a path connecting two distinct vertices off the cycle and whose edges are interior edges.
</p>
<!--TOC section id="sec5" Regular edge labellings-->
<h2 id="sec5" class="section">3  Regular edge labellings</h2><!--SEC END --><p>
<a id="s:rel"></a>

<span style="font-weight:bold">Adjacency graphs of layouts.</span>
In an <em>adjacency graph</em> <span style="color:red"><span style="font-style:italic">G</span></span>(<span style="color:red"><span style="font-style:italic">L</span></span>) of a layout <span style="color:red"><span style="font-style:italic">L</span></span> each rectangle is represented by a vertex.
In an adjacency graph we connect two vertices by an edge exactly when their rectangles are adjacent.
In the <em>extended adjacency graph</em> <span style="color:red"><span style="font-style:italic">G</span></span><sub><span style="color:red"><span style="font-style:italic">E</span></span></sub>(<span style="color:red"><span style="font-style:italic">L</span></span>) we also add 4 vertices <span style="font-style:italic">N</span>, <span style="font-style:italic">E</span>, <span style="font-style:italic">S</span>, <span style="font-style:italic">W</span> (so-called <em>poles</em>) in the outer face, one associated to the north, east, south, west boundary segment of the outer rectangle, respectively.
In this graph two vertices are connected if their rectangles or boundary segments intersect.
If we take the <em>extended adjacency graph</em> of a layout and remove the 4 vertices corresponding to the outer face we end up with the regular <em>adjacency graph</em> of that layout.
In this setting a layout <span style="color:red"><span style="font-style:italic">L</span></span> is a <em>rectangular dual</em> of a graph <span style="font-style:italic">G</span> if we have that <span style="font-style:italic">G</span> = <span style="color:red"><span style="font-style:italic">G</span></span>(<span style="color:red"><span style="font-style:italic">L</span></span>).</p><p><span style="font-weight:bold">Regular edge labellings.</span>
Given a layout <span style="color:red"><span style="font-style:italic">L</span></span> we can easily find its adjacency graph and thus for which graph <span style="font-style:italic">G</span> it is a rectangular dual. However, finding a rectangular dual of a graph <span style="font-style:italic">G</span> is more involved. Due to the algorithm by He [<a href="#He1993"></a>] it is sufficient to find a <em>regular edge labeling</em> on a corner assignment of <span style="font-style:italic">G</span>. In this section we introduce regular edge labellings.</p><p>Regular edge labellings were first introduced by Kant and He [<a href="#Kant1997"></a>].
Fusy also studied these structures [<a href="#Fusy2009"></a>, <a href="#Fusy2006"></a>] under the name of <em>transversal structures</em>.
A <em>regular edge labeling</em> is a coloring and orientation of the edges of the extended adjacency graph <span style="color:red"><span style="font-style:italic">G</span></span><sub><span style="color:red"><span style="font-style:italic">E</span></span></sub>(<span style="color:red"><span style="font-style:italic">L</span></span>).
This coloring and orientation is given by the following procedure.
For every edge <span style="font-style:italic">vw</span> in <span style="color:red"><span style="font-style:italic">G</span></span><sub><span style="color:red"><span style="font-style:italic">E</span></span></sub>(<span style="color:red"><span style="font-style:italic">L</span></span>) we consider whether the shared boundary of the rectangles is vertical or horizontal and we color the corresponding edge blue or red, respectively.
If we color the edge blue we orient it from the leftmost rectangle to the rightmost rectangle and if we color it red we orient from bottom to top.
We neither color nor orient the edges between the poles.</p><p>From the nature of the adjacencies in a rectangular layout we can deduce the following two rules, both illustrated in Figure <a href="#fig%3Arel%3Aconditions">??</a>, for a regular edge labeling.</p><ol class="enumerate" type=1><li class="li-enumerate">
(Interior vertex) In the angular order of every interior vertex we have the following subsequent non-empty sets: Incoming red edges, incoming blue edges, outgoing red edges and outgoing blue edges and these are the only sets that exist.
</li><li class="li-enumerate">(Pole) <span style="font-style:italic">N</span> has only incoming red edges, <span style="font-style:italic">E</span> has only incoming blue edges, <span style="font-style:italic">S</span> has only outgoing red edges and <span style="font-style:italic">W</span> has only outgoing blue edges, except for the uncolored edges between the poles.
</li></ol><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
[b]0.2 @percent
<img src="thesis020.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 8: Interior vertex condition</td></tr>
</table></div>

 
[b]0.7 @percent
<img src="thesis021.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 9: Pole condition</td></tr>
</table></div>

<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 10: Regular edge labeling conditions</td></tr>
</table></div>
<a id="fig:rel:conditions"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><p>
In [<a href="#He1993"></a>] He showed that given a regular edge labeling of a corner assignment we can reconstruct a rectangular layout represented by this regular edge labeling.</p><p><span style="font-weight:bold">Combinatorially equivalent.</span>
We say two duals of <span style="font-style:italic">G</span> are <em>combinatorially equivalent</em> or simply <em>equivalent</em> when they give raise to the same regular edge labeling of Ḡ. That is, their rectangles have the same adjacencies with the same orientation (horizontal or vertical).</p><p><span style="font-weight:bold">Properties.</span>
Since we often use regular edge labellings in this thesis we prove some properties for them. We show that a regular edge labeling has no mono-colored triangles and that the red and blue subgraph of a regular edge labeling both form a <span style="font-style:italic">st</span>-planar graph.</p><div class="theorem"><span style="font-weight:bold">Observation 1</span> <span style="font-weight:bold">(Fusy, </span><span style="font-weight:bold">[</span><a href="#Fusy2009"></a><span style="font-weight:bold">]</span><span style="font-weight:bold">)</span>  <em>
</em><a id="obs:rel:noMonoColoredTriangles"></a><em>
A regular edge labeling has no monochromatic triangles even when ignoring orientation.
</em></div><p><span style="font-weight:bold">Proof.</span>
Suppose we have a monochromatic triangle. Without loss of generality we suppose this triangle is blue. Then at least one of the vertices has an incoming blue edge followed directly by an outgoing blue edge or an outgoing blue edge followed directly by an incoming blue edge in its angular order. Thus, this vertex has either an empty set of outgoing or incoming red edges and hence violates the interior vertex condition of a regular edge labeling.
</p><p><br>
</p><p><span style="font-weight:bold"><span style="font-style:italic">st</span></span><span style="font-weight:bold">-planar graphs.</span>
In this thesis we repeatedly use regular edge labellings, so it is a good idea to investigate their structure.
Kant and He [<a href="#Kant1997"></a>] and Fusy [<a href="#Fusy2009"></a>] both note that a regular edge labeling is closely linked to a pair of <span style="font-style:italic">st</span><em>-planar graphs</em>. <span style="font-style:italic">st</span>-planar graphs are also known under the name of <em>bipolar orientations</em>.
We state this observation in the same way it is stated by Fusy, which is slightly different from the way Kant and He state it.
An <span style="font-style:italic">st</span>-planar graph is an oriented planar graph with one source (in-degree 0) <span style="font-style:italic">s</span> and one sink (out-degree 0) <span style="font-style:italic">t</span>. Both <span style="font-style:italic">s</span> and <span style="font-style:italic">t</span> lie on the outer face. Moreover, such an <span style="font-style:italic">st</span>-planar graph has no directed cycles.</p><div class="theorem"><span style="font-weight:bold">Observation 2</span> <span style="font-weight:bold">(Fusy, </span><span style="font-weight:bold">[</span><a href="#Fusy2009"></a><span style="font-weight:bold">]</span><span style="font-weight:bold">)</span>  <em>
</em><a id="obs:rel:stPlanarGraphs"></a><em>
The blue edges of </em><span style="font-style:italic">G</span>∖ <span style="font-style:italic">N</span>,<span style="font-style:italic">S</span>  <em> form an </em><span style="font-style:italic">st</span><em>-planar graph with </em><span style="font-style:italic">s</span>= <span style="font-style:italic">W</span><em> and </em><span style="font-style:italic">t</span>=<span style="font-style:italic">E</span><em>. Moreover, the red edges of </em><span style="font-style:italic">G</span>∖ <span style="font-style:italic">W</span>,<span style="font-style:italic">E</span>  <em> form an </em><span style="font-style:italic">st</span><em>-planar graph with </em><span style="font-style:italic">s</span>= <span style="font-style:italic">S</span><em> and </em><span style="font-style:italic">t</span>= <span style="font-style:italic">N</span><em>.
</em></div><p><span style="font-weight:bold">Proof.</span>
Note that we have no monochromatic directed cycles because such a cycle would for example correspond to a group of adjacent rectangles that have no leftmost or topmost one. By the interior vertex condition interior vertices can not be sources or sinks, this leaves the non-removed poles to be the sources and sinks, as required.
</p><p><br>
</p><p>We refer to these <span style="font-style:italic">st</span>-planar graphs as the <em>blue graph</em> and <em>red graph</em> of some regular edge labeling and we refer to their faces as <em>blue faces</em> and <em>red faces</em>. An example of such a colored extended adjacency graph with the blue and red graph can be found in Figure <a href="#fig%3Arect%3ArelSegmentFace">??</a>.</p><p>Every face <span style="font-style:italic">F</span> in an <span style="font-style:italic">st</span>-planar graph has the same structure. The boundary of <span style="font-style:italic">F</span> consists of two directed paths, so-called <em>boundary paths</em>, with common start vertex <span style="font-style:italic">v</span> and end vertex <span style="font-style:italic">w</span>. We say <span style="font-style:italic">v</span> is the <em>split</em> vertex of <span style="font-style:italic">F</span> and <span style="font-style:italic">w</span> is the <em>merge</em> vertex of <span style="font-style:italic">F</span>.
These boundary paths are subsequent in the clockwise angular order at <span style="font-style:italic">v</span>. We say the first path in the angular order, starting at the beginning of the adjacent pair, is the <em>top boundary path</em> (blue graph) or <em>left boundary path</em> (red graph) of <span style="font-style:italic">F</span> and the second one is the <em>bottom boundary path</em> (blue graph) or <em>right boundary path</em> (red graph).</p><p><span style="font-weight:bold">Maximal segments.</span>
Due to the way we color a regular edge labeling of <span style="color:red"><span style="font-style:italic">G</span></span><sub><span style="color:red"><span style="font-style:italic">E</span></span></sub>(<span style="color:red"><span style="font-style:italic">L</span></span>) given a layout <span style="color:red"><span style="font-style:italic">L</span></span> a horizontal maximal segment corresponds to a blue face and a vertical maximal segment corresponds to a red face; as one can see in Figure <a href="#fig%3Arect%3ArelSegmentFace">??</a>.</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
<img src="thesis022.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 11: An example regular edge labeling with corresponding rectangular dual.</td></tr>
</table></div>
<a id="fig:rect:relSegmentFace"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><p>Let us consider a face corresponding to a maximal segment.
The number of internal vertices of both boundary paths without counting the split and merge vertices is the number of rectangles on the respective sides of the maximal segment.
Hence, a one-sided maximal segment corresponds to a face with one boundary path of length 2 and a <span style="font-style:italic">k</span>-sided maximal segment to a face with the shortest boundary path of length at most <span style="font-style:italic">k</span>+1.
We can not have faces with a boundary path of length 1 since such a face can not enclose a valid segment.</p><div class="theorem"><span style="font-weight:bold">Observation 3</span>  <em>
</em><a id="obs:rel:noBpOfLength1"></a><em>
No face can have a boundary path of length </em>1<em>.
</em></div><p><span style="font-weight:bold">Proof.</span>
A boundary path can not have length 1 since by construction of a regular edge labeling a red or blue face encloses a maximal segment and thus has to go through at least one intermediate rectangle, and thus through at least one intermediate vertex.
</p><p><br>
</p><p>This observation generalizes the observation that we can not have monochromatic triangles.
</p>
<!--TOC section id="sec6" A family of graphs not <span style="font-style:italic">k</span>-sided for any <span style="font-style:italic">k</span>-->
<h2 id="sec6" class="section">4  A family of graphs not <span style="font-style:italic">k</span>-sided for any <span style="font-style:italic">k</span></h2><!--SEC END --><p>

<a id="s:fix"></a>
In this section we prove the following theorem.</p><div class="theorem"><span style="font-weight:bold">Theorem 4</span>  <em>
</em><a id="fix:th:family"></a><em>
There is a family of graphs </em><span style="font-style:italic">G</span><sub><span style="font-style:italic">k</span></sub><em> that, for any </em><span style="font-style:italic">k</span> ∈ ℕ<em>, has members that are not </em><span style="font-style:italic">k</span><em>-sided.
</em></div><p>All members of this family <span style="font-style:italic">G</span><sub><span style="font-style:italic">k</span></sub> contain separating 4-cycles.
The maximum vertex degree, <span style="font-style:italic">d</span>, of <span style="font-style:italic">G</span><sub><span style="font-style:italic">k</span></sub> is about 2<span style="font-style:italic">k</span>+<span style="font-style:italic">O</span>(1). This also means that in principle it might be possible to create an algorithm providing <span style="font-style:italic">O</span>(<span style="font-style:italic">d</span>)-sided layouts for any corner assignment; that our algorithm in Section <a href="#s%3Aalgo">??</a> only works for corner assignments without separating 4-cycles.</p><p>[16]r6cm
<img src="thesis023.png">
The structure inside a separating 4-cycle.
<a id="fig:fix:sep4cycle"></a>
</p><p><span style="font-weight:bold">Multiple corner assignments.</span>
If there is no <span style="font-style:italic">k</span>-sided rectangular dual for a certain corner assignment Ḡ of <span style="font-style:italic">G</span>, there may still be another corner assignment of <span style="font-style:italic">G</span> that admits a <span style="font-style:italic">k</span>-sided dual.
However, if we use  <span style="font-style:italic">H</span><sub><span style="font-style:italic">k</span></sub> = Ḡ<sub><span style="font-style:italic">k</span></sub> as an auxiliary graph we note that <span style="font-style:italic">G</span><sub><span style="font-style:italic">k</span></sub> is the interior of a separating 4-cycle of <span style="font-style:italic">H</span><sub><span style="font-style:italic">k</span></sub>. This auxiliary graph will be known as <em>scaffold</em> of <span style="font-style:italic">G</span><sub><span style="font-style:italic">k</span></sub>.
We prove in Lemma <a href="#lm%3Afix%3AfourCycleInteriorColor">??</a> this implies that <span style="font-style:italic">G</span><sub><span style="font-style:italic">k</span></sub>, as induced subgraph, has to be colored in accordance with the corner assignment Ḡ<sub><span style="font-style:italic">k</span></sub>.
We first prove Lemma <a href="#lm%3Afix%3AfourCycleInteriorColor">??</a> before we prove Theorem <a href="#fix%3Ath%3Afamily">??</a>.</p><div class="theorem"><span style="font-weight:bold">Lemma 5</span>  <em>
</em><a id="lm:fix:fourCycleInteriorColor"></a><em>
Let </em><span style="color:red"><span style="font-style:italic">C</span></span><em> be a separating </em>4<em>-cycle of </em>Ḡ<em> with interior </em><span style="color:red"><span style="font-style:italic">I</span></span><em>. We can label the vertices of </em><span style="font-style:italic">I</span><em> by </em><span style="font-style:italic">a</span><em>, </em><span style="font-style:italic">b</span><em>, </em><span style="font-style:italic">c</span><em> and </em><span style="font-style:italic">d</span><em> in clockwise order such that all interior edges incident to </em><span style="font-style:italic">a</span>, <span style="font-style:italic">b</span>, <span style="font-style:italic">c</span><em> and </em><span style="font-style:italic">d</span><em> are incoming red, incoming blue, outgoing red and outgoing blue, respectively.
</em></div><p><span style="font-weight:bold">Proof.</span>
The interior <span style="font-style:italic">I</span> of <span style="color:red"><span style="font-style:italic">C</span></span> is represented by some rectilinear shape in every rectangular dual <span style="color:red"><span style="font-style:italic">L</span></span> of Ḡ. Such a shape must have at least 4 clockwise right turns if we travel along its boundary in a clockwise direction otherwise the shape is not closed.</p><p>Yet, such a clockwise turn can not occur due to a single rectangle. Instead, such a turn can only occur when two rectangles are adjacent to each other. Because a 4-cycle represents only 4 pairs of adjacent rectangles, the representation of <span style="font-style:italic">I</span> in <span style="color:red"><span style="font-style:italic">L</span></span> can only have 4 clockwise turns. Hence, it must be a rectangle, the only rectilinear shape with just 4 clockwise turns.</p><p>The interior <span style="font-style:italic">I</span> of <span style="color:red"><span style="font-style:italic">C</span></span> is represented by a rectangle <span style="color:red"><span style="font-style:italic">I</span></span> in any rectangular dual. Since two disjoint rectangles can only be adjacent to each other at one side, <span style="color:red"><span style="font-style:italic">I</span></span> has four sides that need to be covered and <span style="color:red"><span style="font-style:italic">I</span></span> is adjacent to only four rectangles we know that every side of the rectangle <span style="color:red"><span style="font-style:italic">I</span></span> is adjacent to a single rectangle. We then denote by <span style="font-style:italic">a</span> the vertex corresponding to the rectangle above <span style="color:red"><span style="font-style:italic">I</span></span>, <span style="font-style:italic">b</span> the rectangle right of <span style="color:red"><span style="font-style:italic">I</span></span>, <span style="font-style:italic">c</span> the rectangle below <span style="color:red"><span style="font-style:italic">I</span></span> and <span style="font-style:italic">d</span> the rectangle left of <span style="color:red"><span style="font-style:italic">I</span></span>.
The construction at the end of the proof can also be seen in Figure <a href="#fig%3Afix%3Asep4cycle">??</a>.</p><p>Then the required coloring follows from how a regular edge labeling is obtained from a layout.
</p><p><br>
</p><p>Hence, if we know the color and orientation of one interior edge incident to a vertex of a separating 4-cycle <span style="color:red"><span style="font-style:italic">C</span></span> we know the color and orientation of all interior edges of <span style="color:red"><span style="font-style:italic">C</span></span> incident to <span style="color:red"><span style="font-style:italic">C</span></span>.</p><p>R6cm
</p><table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-style:italic">NE</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-style:italic">N</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-style:italic">E</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-style:italic">SE</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-style:italic">NW</span> </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-style:italic">SE</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-style:italic">S</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-style:italic">E</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-style:italic">NE</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-style:italic">SW</span></td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-style:italic">SW</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-style:italic">S</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-style:italic">W</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-style:italic">SE</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-style:italic">NW</span></td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-style:italic">NW</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><span style="font-style:italic">N</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-style:italic">W</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-style:italic">NE</span></td><td style="text-align:center;border:solid 1px;white-space:nowrap" > <span style="font-style:italic">SW</span></td></tr>
</table><p>
The neighbors of the new poles.
<a id="tab:scaffold"></a>
</p><p>Lemma <a href="#lm%3Afix%3AfourCycleInteriorColor">??</a> is useful because it allows us to consider a single corner assignment Ḡ of <span style="font-style:italic">G</span> by using it as scaffold. Suppose we want to investigate some specific corner assignment Ḡ of <span style="font-style:italic">G</span> with poles <span style="font-style:italic">N</span>, <span style="font-style:italic">E</span>, <span style="font-style:italic">S</span> and <span style="font-style:italic">W</span> then we consider the graph Ḡ = <span style="font-style:italic">H</span> as a graph in its own right, and inspect the coloring of this graph.</p><p><span style="font-style:italic">H</span> admits a corner assignment <span style="text-decoration:overline">H</span> without separating triangles by connecting the new poles as indicated in Table <a href="#tab%3Ascaffold">??</a>.
<span style="text-decoration:overline">H</span> is shown in Figure <a href="#fig%3Ascafold">??</a>.
<span style="font-style:italic">G</span> is displayed in thick lines and with filled vertices.
An arbitrary corner assignment Ḡ =<span style="font-style:italic">H</span> is then drawn with thin lines and hollow vertices.
A corner assignment of <span style="font-style:italic">H</span> is then drawn with dashed edges and hollow vertices.</p><p>r8cm
<img src="thesis024.png">
The construction of a scaffold.
<a id="fig:scafold"></a>
</p><p>The graph <span style="font-style:italic">H</span> can have more than one</p><p>corner assignment but they all contain the separating 4-cycle <span style="color:red"><span style="font-style:italic">C</span></span>= <span style="font-style:italic">NESW</span>. Thus, by Lemma <a href="#lm%3Afix%3AfourCycleInteriorColor">??</a> we see that, without loss of generality, the interior edges of <span style="color:red"><span style="font-style:italic">C</span></span> incident to <span style="font-style:italic">N</span> are colored incoming red, those incident to <span style="font-style:italic">E</span> are colored incoming blue, those incident to <span style="font-style:italic">S</span> are colored outgoing red and those incident to <span style="font-style:italic">W</span> are colored outgoing blue.</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
<img src="thesis025.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 12: A family of graphs not <span style="font-style:italic">k</span>-sided for any <span style="font-style:italic">k</span>.</td></tr>
</table></div>
<a id="fig:fix:manymany0"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><p><span style="font-weight:bold">Proof.</span>[Proof of Theorem <a href="#fix%3Ath%3Afamily">??</a>]
Now we can consider the family of graphs <span style="font-style:italic">G</span><sub><span style="font-style:italic">k</span></sub> with the corner assignment Ḡ<sub><span style="font-style:italic">k</span></sub> given in Figure <a href="#fig%3Afix%3Amanymany0">??</a>.
We know we only have to consider this corner assignment since we can force it using a scaffold and Lemma <a href="#lm%3Afix%3AfourCycleInteriorColor">??</a>.
In <span style="font-style:italic">G</span><sub>1</sub> the dots are replaced by a single vertex, in <span style="font-style:italic">G</span><sub>2</sub> the dots are replaced by two vertices and so on.
Each member has 2 maximal separating 4-cycles.
These are both marked by thick lines in Figure <a href="#fig%3Afix%3Amanymany0">??</a>.
Many of the edges in this graph have only one possible color and orientation violating the constraints of a regular edge labeling.
Firstly, we color the edges incident with the poles in accordance with the exterior vertex condition.
Subsequently, we can use Lemma <a href="#lm%3Afix%3AfourCycleInteriorColor">??</a> on both maximal separating 4-cycles to color even more edges and finally we can color the edges in triangles of which the other two edges have the same color using Observation <a href="#obs%3Arel%3AnoMonoColoredTriangles">??</a>.
All these forced colorings are performed in Figure <a href="#fig%3Afix%3Acoloring">??</a>.</p><p>The result is then the graph displayed in Figure <a href="#fig%3Afix%3Amanymany4">??</a>. The black edges in this figure are edges that do not have a forced coloring by the above argument (Although most of them can be forced by Lemma <a href="#lm%3Afix%3AfourCycleInteriorColor">??</a>).
We focus on the centered black edge <span style="font-style:italic">e</span>, <span style="font-style:italic">e</span> is an interior edge of both the red and blue faces drawn with dashed edges in Figure <a href="#fig%3Afix%3Amanymany4">??</a>. Both boundary paths of these faces are of length larger than <span style="font-style:italic">k</span>. Hence, <span style="font-style:italic">e</span> has to be colored both red and blue to prevent that face corresponding to a <span style="font-style:italic">k</span>-sided segment occurs in the regular edge labeling. Since an edge can not be colored red and blue at the same time <span style="font-style:italic">G</span><sub><span style="font-style:italic">k</span></sub> is not <span style="font-style:italic">k</span>-sided.</p><p>Since this proof does not depend on the value of <span style="font-style:italic">k</span>, the family <span style="font-style:italic">G</span><sub><span style="font-style:italic">k</span></sub> has graphs that are not <span style="font-style:italic">k</span>-sided for any <span style="font-style:italic">k</span>.
</p><p><br>
</p><p>  </p><p>  </p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
[t]0.3@percent
<img src="thesis026.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 13: Coloring the edges adjacent to the poles.</td></tr>
</table></div>
<a id="fig:fix:manymany1"></a>

  [t]0.3@percent
<img src="thesis027.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 14: Propagate through the separating 4-cycle.</td></tr>
</table></div>
<a id="fig:fix:manymany2"></a>

  [t]0.3@percent
<img src="thesis028.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 15: Colors chosen such that there are no monochromatic triangles.</td></tr>
</table></div>
<a id="fig:fix:manymany3"></a>

<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 16: Coloring the graph.</td></tr>
</table></div>
<a id="fig:fix:coloring"></a>
<img src="thesis029.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 17: The graph after all coloring steps.</td></tr>
</table></div>
<a id="fig:fix:manymany4"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote>
<!--TOC section id="sec7" The algorithm-->
<h2 id="sec7" class="section">5  The algorithm</h2><!--SEC END --><p>

<a id="s:algo"></a></p><p><span style="font-weight:bold">Algorithms for regular edge labellings.</span>
Kant and He [<a href="#Kant1997"></a>] were the first to design algorithms that determine a regular edge labeling given a graph <span style="font-style:italic">G</span>. Fusy [<a href="#Fusy2006"></a>] developed a different algorithm computing a specific regular edge labeling using a method which shrinks a cycle while coloring the exterior of this cycle in accordance with a regular edge labeling.
He refers to such a cycle as a <em>sweepcycle</em>.
Unfortunately his proof of this algorithm is rather concise, leaving rather much room for the reader to fill in the details.</p><p>In this algorithm Fusy starts by denoting the outer cycle of Ḡ ∖ <span style="font-style:italic">N</span>   as the sweepcycle <span style="color:red"><span style="font-style:italic">C</span></span>. He then shrinks this sweepcycle by updating it with interior paths of <span style="color:red"><span style="font-style:italic">C</span></span>. During this update he maintains invariants on the structure of both the cycle and its exterior.
After doing a finite amount of updates, the sweepcycle has no more interior vertices. At this point Fusy completes the algorithm and obtains a regular edge labeling.</p><p>[33]r8.2cm
<img src="thesis030.png">
The flow of the algorithm.
<a id="fig:algo:algoflow"></a>
</p><p><span style="font-weight:bold">Our algorithm.</span>
In this section we will present an algorithm providing a <span style="font-style:italic">d</span>-sided rectangular dual for any corner assignment Ḡ without separating 4-cycles, where <span style="font-style:italic">d</span> is the highest degree among vertices of <span style="font-style:italic">G</span> in Ḡ. Hence, we will prove the following theorem.</p><div class="theorem"><span style="font-weight:bold">Theorem 6</span>  <em>
</em><a id="th:dsided"></a><em>
Graphs </em><span style="font-style:italic">G</span><em> that have a corner assignment </em>Ḡ<em> without separating 4-cycles are </em><span style="font-style:italic">d</span>−1<em>-sided, where </em><span style="font-style:italic">d</span><em> is the maximal degree of the vertices of </em><span style="font-style:italic">G</span><em> in </em>Ḡ<em>.
</em></div><p>Our algorithm will need a number of steps to get to the stated result. In Figure <a href="#fig%3Aalgo%3Aalgoflow">??</a> we can see the four main step we need for finding a <span style="font-style:italic">d</span>−1 sided layout. In every step we ensure new restrictions while maintaining the old ones. In the last step, "Blue Face Subdivision", we can then use these accumulated restrictions to build a <span style="font-style:italic">d</span>−1 sided layout.</p><p>The first step is finding a regular edge labeling with a certain restriction on <em>splitvertices</em>, vertices having more than one blue outgoing edge.
We show that these splitvertices can not be next to something we call the handle of a large topfan, that is, a vertex that has more than two incoming red edges.</p><p>In the second step we will make sure that our regular edge labeling <span style="font-style:italic">L</span> is <em>vertically one-sided</em>. That is, all vertical segments in the corresponding rectangular layout are one-sided segments.
We can translate this to a condition on the red faces of <span style="font-style:italic">L</span>, and this condition can then be translated to the existence of a structure we call a <em>blue </em><span style="font-style:italic">Z</span>. In this step we resolve all occurrences of such blue <span style="font-style:italic">Z</span>’s.
We suspect that this step is not necessary because the regular edge labeling provided by the sweepcycle algorithm is already vertically one-sided. However, we were unable to prove this.</p><p>r6cm
<img src="thesis031.png">
The thick edges are a topfan.
<a id="fig:algo:topfanExample"></a>
</p><p>The third step then consists of handling most topfans in the regular edge labeling by "Flipping" them.
A <em>topfan</em> is a several red edges going to the same vertex in a triangle strip that is formed by a blue face.
Such a topfan is <em>large</em> when this has at least three incoming red edges.
In Figure <a href="#fig%3Aalgo%3AtopfanExample">??</a> an example of a large topfan is given by the thick edges.
This is the most difficult for those topfans that are adjacent to a splitvertex and hence we have to ignore some of these.
If we had been able to handle all topfans, finding a <span style="font-style:italic">k</span>-sided layout would have been easier.</p><p>However, due to the restriction on split vertices we have maintained during the algorithm and the fact that all remaining topfans are adjacent to such splitvertices we are still able to produce a <span style="font-style:italic">d</span>−1 sided layout in the last step.</p><p><span style="font-weight:bold">Overview.</span>
To describe our algorithm we introduce the notion of right neighbor paths in Section <a href="#ss%3ArightNeighbour">??</a>. This notion will be heavily used in the sweepcycle algorithm in Section <a href="#ss%3Asweep">??</a>. In the rest of the section we describe the rest of the algorithm, please refer to Figure <a href="#fig%3Aalgo%3Aalgoflow">??</a> to see which steps are described in what section.
</p>
<!--TOC subsection id="sec8" The right neighbor path of a path-->
<h3 id="sec8" class="subsection">5.1  The right neighbor path of a path</h3><!--SEC END --><p>

<a id="ss:rightNeighbour"></a>
In the sweepcycle step of the algorithm (Section <a href="#ss%3Asweep">??</a>) we use the <em>right neighbor path</em> of a path. In this section we show that for any path <span style="font-style:italic">P</span> = <span style="font-style:italic">p</span><sub>1</sub> … <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub> with no internal vertices incident to the outer face and without violating chords, which we will introduce shortly, on the right of the path, the right side neighbors of <span style="font-style:italic">P</span> are again a path <span style="font-style:italic">Q</span> (Lemma <a href="#lm%3Aright%3AneighborPath">??</a>).
We even show some additional properties hold for <span style="font-style:italic">Q</span> (Lemma <a href="#lm%3Aright%3AneighbourwalkNoInteriorVertex">??</a> and <a href="#lm%3Aright%3AneighbourwalkChordFree">??</a>).
Similar things also hold for the left neighbors of <span style="font-style:italic">P</span> but we do not need this for our algorithm.</p><p>The right side of a path is not yet defined. To do so we start this section by expanding on the notion of angular orders. During the proofs in this section we also need various types of chords so we subsequently introduce these. Afterwards, we can finally discuss right neighbor paths.</p><p>r5cm
<img src="thesis032.png">
Angular order of <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub>.
<a id="fig:right:rot"></a>
</p><p><span style="font-weight:bold">Angular orders.</span>
We assume a fixed embedding for <span style="font-style:italic">G</span>. Recall that the order at a vertex <span style="font-style:italic">v</span> is the clockwise order of the edges incident to <span style="font-style:italic">v</span> and that two vertices <span style="font-style:italic">x</span>, <span style="font-style:italic">y</span> are said to be <em>consecutive</em> in the angular order at <span style="font-style:italic">v</span> when the edges <span style="font-style:italic">vx</span> and <span style="font-style:italic">vy</span> are consecutive in the angular order.
Sometimes, we want to denote number of subsequent vertices, which we call an <em>interval</em>, in the angular order. We let [<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>] denote all the vertices in the angular order of <span style="font-style:italic">v</span> from <span style="font-style:italic">x</span> to <span style="font-style:italic">y</span> and we let the <em>exclusive interval</em> (<span style="font-style:italic">x</span>,<span style="font-style:italic">y</span>) denote the same vertices without <span style="font-style:italic">x</span> and <span style="font-style:italic">y</span>. In Figure <a href="#fig%3Aright%3Arot">??</a>, for example, the interval [<span style="font-style:italic">v</span>,<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub>] consists of the vertices <span style="font-style:italic">v</span>,<span style="font-style:italic">w</span>,<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub> and (<span style="font-style:italic">w</span>,<span style="font-style:italic">u</span>) consists of the vertices <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub>, <span style="font-style:italic">x</span>.</p><p>Given a path <span style="font-style:italic">P</span> and an internal vertex <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> ∈ <span style="font-style:italic">P</span>. A neighbor <span style="font-style:italic">v</span> ∉ <span style="color:red"><span style="font-style:italic">P</span></span> of <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> lies on the <em>left</em> of <span style="font-style:italic">P</span> if it lies in the interval (<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>−1</sub>, <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub>) in the angular order of <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub>. Otherwise, <span style="font-style:italic">v</span> lies in the interval (<span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub>, <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>−1</sub>) in the angular order of <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub>. In this case <span style="font-style:italic">v</span> lies on the <em>right</em> of <span style="font-style:italic">P</span>.
We use the same notion of left and right for edges. That is, an edge <span style="font-style:italic">e</span>∉ <span style="font-style:italic">P</span> adjacent to <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> lies to left or right if its other end point lies to the left or right, respectively. In Figure <a href="#fig%3Aright%3Arot">??</a> <span style="font-style:italic">v</span> and <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">v</span> lie on the left of <span style="font-style:italic">P</span> and <span style="font-style:italic">u</span> and <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">u</span> lie on the right of <span style="font-style:italic">P</span>.</p><p><span style="font-weight:bold">Path manipulations.</span>
With ↼<span style="font-style:italic">P</span> we denote the <em>reversed path</em> <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub> … <span style="font-style:italic">p</span><sub>1</sub>. We use ⊕ to denote the <em>concatenation</em> of paths.
That is, given a second path <span style="font-style:italic">Q</span> with vertices <span style="font-style:italic">q</span><sub>1</sub> … <span style="font-style:italic">q</span><sub>ℓ</sub> and <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub> = <span style="font-style:italic">q</span><sub>1</sub> the path <span style="font-style:italic">P</span> ⊕ <span style="font-style:italic">Q</span> consists of <span style="font-style:italic">p</span><sub>1</sub> … <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span>−1</sub> <span style="font-style:italic">q</span><sub>1</sub> <span style="font-style:italic">q</span><sub>2</sub> … <span style="font-style:italic">q</span><sub>ℓ</sub>.
Recall that a cycle is simply a path starting and ending at the same vertex.
Hence, if we have two internally disjoint paths <span style="font-style:italic">P</span>, <span style="font-style:italic">Q</span> from <span style="font-style:italic">s</span> to <span style="font-style:italic">t</span> then <span style="font-style:italic">P</span> ⊕ ↼<span style="font-style:italic">Q</span> is a cycle.
Furthermore, we use a vertical bar to denote the <em>restriction</em> of a path to a certain set of vertices. So <span style="font-style:italic">P</span>|<sub><span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub>, <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub></sub> with <span style="font-style:italic">i</span>&lt;<span style="font-style:italic">j</span> is the subpath of <span style="font-style:italic">P</span> with vertices <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> … <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>.</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
<img src="thesis033.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 18: A path with a chord and a separating 2-chord.</td></tr>
</table></div>
<a id="fig:right:chord"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><p><span style="font-weight:bold">Violating chords.</span>
A <em>chord</em> of a path is an edge that connects two non-subsequent vertices. A path without chords is <em>chordfree</em>. The path <span style="font-style:italic">P</span> in Figure <a href="#fig%3Aright%3Achord">??</a> has the chord <span style="font-style:italic">p</span><sub>1</sub> <span style="font-style:italic">p</span><sub>3</sub>.
A <em>k-chord</em> is a path <span style="font-style:italic">C</span> of length <span style="font-style:italic">k</span> that connects two non-subsequent vertices <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub>, <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub> of <span style="font-style:italic">P</span> such that <span style="font-style:italic">P</span> ∩ <span style="font-style:italic">C</span> = <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub>, <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub> .
Note that <span style="font-style:italic">P</span>|<sub><span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub>, <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub></sub> ⊕ ↼<span style="font-style:italic">C</span> is a cycle.
A (<span style="font-style:italic">k</span>-)chord <span style="font-style:italic">C</span> is <em>separating</em> if this cycle is separating.
In Figure <a href="#fig%3Aright%3Achord">??</a> there are two 2-chords, <span style="font-style:italic">p</span><sub>3</sub> <span style="font-style:italic">u</span> <span style="font-style:italic">p</span><sub>5</sub> and <span style="font-style:italic">p</span><sub>3</sub> <span style="font-style:italic">v</span> <span style="font-style:italic">p</span><sub>5</sub>, but only one of them is separating, namely <span style="font-style:italic">p</span><sub>3</sub> <span style="font-style:italic">v</span> <span style="font-style:italic">p</span><sub>5</sub>.
The <em>violating chords</em> are given by all chords and separating 2-chords together. We use this name since we can not find a right neighbor path when we have such violating chords. In Figure <a href="#fig%3Aright%3Achord">??</a> <span style="font-style:italic">p</span><sub>1</sub><span style="font-style:italic">p</span><sub>3</sub> and <span style="font-style:italic">p</span><sub>3</sub> <span style="font-style:italic">v</span> <span style="font-style:italic">p</span><sub>5</sub> are violating chords while <span style="font-style:italic">p</span><sub>3</sub> <span style="font-style:italic">u</span> <span style="font-style:italic">p</span><sub>5</sub> is not.</p><p><span style="font-weight:bold">Right neighbor paths.</span>
We already mentioned that in the sweepcycle step we use the right neighbor path of a path <span style="font-style:italic">P</span>. Recall that we assumed <span style="font-style:italic">P</span> has no internal vertices incident to the outer face and no chords or separating 2-chords on the right.
We first show that every vertex has right neighbors.
Then we give the procedure for finding the right neighbor path.
Afterwards we show that the right neighbor path is indeed a path (Lemma <a href="#lm%3Aright%3AneighborPath">??</a>) and some additional properties in Lemmas <a href="#lm%3Aright%3AneighbourwalkNoInteriorVertex">??</a> and <a href="#lm%3Aright%3AneighbourwalkChordFree">??</a>.</p><div class="theorem"><span style="font-weight:bold">Lemma 7</span>  <em>
</em><a id="lm:right:pHasRightNeihgbours"></a><em>
Every internal vertex of </em><span style="font-style:italic">P</span><em> has at least one neighboring vertex on the right.
</em></div><p><span style="font-weight:bold">Proof.</span>
Suppose that an internal vertex <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> has no neighbor on the right of the path. Then  … <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>−1</sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub> …  is a partial face border. Since <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> is not incident to the outer face, <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> must be incident to a face of degree 3. Thus, <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>−1</sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub> is a face. However, this would imply a chord on the right of <span style="font-style:italic">P</span> as can be seen in Figure <a href="#fig%3Aright%3ApHasRightNeighbor">??</a>. Hence, by contradiction <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> must have a neighbor on the right.
</p><p><br>
</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
<img src="thesis034.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 19: The hypothetical situation that <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> has no right neighbor.</td></tr>
</table></div>
<a id="fig:right:pHasRightNeighbor"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><p>The right neighbors of the internal vertices of <span style="font-style:italic">P</span> form the <em>right neighbor path</em> <span style="font-style:italic">Q</span> of <span style="font-style:italic">P</span>.
Let us first define a larger list of vertices <span style="font-style:italic">Q</span>′ from which we later remove vertices to get <span style="font-style:italic">Q</span>. <span style="font-style:italic">Q</span>′ consists of <span style="font-style:italic">p</span><sub>1</sub> and those vertices adjacent to <span style="font-style:italic">p</span><sub>2</sub> that are in the interval (<span style="font-style:italic">p</span><sub>1</sub>, <span style="font-style:italic">p</span><sub>3</sub>) of the clockwise angular order of <span style="font-style:italic">p</span><sub>2</sub>. Followed by the vertices in the interval (<span style="font-style:italic">p</span><sub>2</sub>, <span style="font-style:italic">p</span><sub>4</sub>) of the angular order of <span style="font-style:italic">p</span><sub>3</sub>. We continue this up to the vertices in the interval (<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span>−2</sub>, <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub>) of the angular order of <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span>−1</sub> and finally <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub>.
We get <span style="font-style:italic">Q</span> from <span style="font-style:italic">Q</span>′ by removing all subsequent duplicates from <span style="font-style:italic">Q</span>.
In Figure <a href="#fig%3Aright%3AneighborPath">??</a> an example of a right neighbor path is given.</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
<img src="thesis035.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 20: A right neighbor path.</td></tr>
</table></div>
<a id="fig:right:neighborPath"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><p>To break the proof that <span style="font-style:italic">Q</span> is a path into two parts we define a <em>walk</em> as a path without the constraint that the same vertex does not occur twice. Hence, a walk is still a sequence of vertices that are connected to each other, but vertices may repeatedly occur.</p><div class="theorem"><span style="font-weight:bold">Lemma 8</span>  <em>
</em><a id="lm:right:neighborWalk"></a><em>
The right neighbor path </em><span style="font-style:italic">Q</span><em> is a walk.
</em></div><p><span style="font-weight:bold">Proof.</span>
Let us denote the vertices of <span style="font-style:italic">Q</span> by <span style="font-style:italic">q</span><sub>1</sub> <span style="font-style:italic">q</span><sub>2</sub> … <span style="font-style:italic">q</span><sub>ℓ</sub>.
Let <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span></sub> and <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span>+1</sub> be two subsequent vertices of <span style="font-style:italic">Q</span>′. We show they are either connected or the same vertex. We first consider the case where 1 &lt; <span style="font-style:italic">i</span> &lt; ℓ−1.
Now there are two sub-cases. Either, (<span style="font-style:italic">a</span>), <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span></sub> and  <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span>+1</sub> are vertices adjacent to the same vertex <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub> and thus subsequent in the angular order of <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub> or, (<span style="font-style:italic">b</span>), <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span></sub> was the last vertex adjacent to <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub> and thus <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span>+1</sub> is the first vertex adjacent to <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span>+1</sub> since by Lemma <a href="#lm%3Aright%3ApHasRightNeihgbours">??</a> every internal vertex of <span style="font-style:italic">P</span> has right neighbors.
Both cases are depicted in Figure <a href="#fig%3Auni%3Awalkproof">??</a>.</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">[t]0.4@percent
<img src="thesis036.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 21: </td></tr>
</table></div>
</div> 
<div class="center">[t]0.4@percent
<img src="thesis037.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 22: </td></tr>
</table></div>
</div>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 23: The two main cases of the proof showing that <span style="font-style:italic">W</span> is a walk.</td></tr>
</table></div>
<a id="fig:uni:walkproof"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><p>In case (<span style="font-style:italic">a</span>) we note that since <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span></sub> and <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span>+1</sub> are subsequent in the angular order of <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span>+1</sub> is an edge since <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub> is not incident to the outer face and every interior face of <span style="font-style:italic">G</span> is a triangle.</p><p>In case (<span style="font-style:italic">b</span>) we note that <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span></sub> and <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub> are edges subsequent in clockwise order, hence <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub> is also an edge. Hence, <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span></sub> is the first vertex adjacent to <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub> subsequent to <span style="font-style:italic">v</span><sub><span style="font-style:italic">i</span></sub> in the clockwise angular order. Thus, <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span></sub> = <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span>+1</sub>, that is <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span></sub> and <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span>+1</sub> are duplicates.</p><p>Now for the cases <span style="font-style:italic">i</span>=1 and <span style="font-style:italic">i</span>=<span style="font-style:italic">k</span>−1. <span style="font-style:italic">q</span><sub>1</sub> and <span style="font-style:italic">q</span><sub>2</sub> are vertices adjacent to <span style="font-style:italic">p</span><sub>2</sub> subsequent in the clockwise angular order of <span style="font-style:italic">p</span><sub>2</sub> and hence connected since every interior face is a triangle. In the same way <span style="font-style:italic">q</span><sub><span style="font-style:italic">k</span>−1</sub> and <span style="font-style:italic">q</span><sub><span style="font-style:italic">k</span></sub> are subsequent vertices in the angular order of <span style="font-style:italic">q</span><sub><span style="font-style:italic">k</span>−1</sub> and hence connected. This can also be seen in Figure <a href="#fig%3Aright%3AneighborPath">??</a>.</p><p>Since all pairs of subsequent vertices in <span style="font-style:italic">Q</span>′ are connected or duplicates the step removing all duplicates from <span style="font-style:italic">Q</span>′ ensures <span style="font-style:italic">Q</span> is a walk.
</p><p><br>
</p><div class="theorem"><span style="font-weight:bold">Lemma 9</span>  <em>
</em><a id="lm:right:neighborPath"></a><em>
The right neighbor path </em><span style="font-style:italic">Q</span><em> is a path.
</em></div><p><span style="font-weight:bold">Proof.</span>
We already know <span style="font-style:italic">Q</span> is a walk by Lemma <a href="#lm%3Aright%3AneighborWalk">??</a>. Hence, we only have to show that <span style="font-style:italic">Q</span> contains no duplicate vertices.</p><div class="minipage">

Suppose that <span style="font-style:italic">Q</span> has a duplicate vertex <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span></sub>=<span style="font-style:italic">q</span><sub><span style="font-style:italic">j</span></sub> with <span style="font-style:italic">i</span>&lt;<span style="font-style:italic">j</span>.
Then this vertex must have been a neighbor to two different vertices in <span style="font-style:italic">P</span>, since it can not have been added twice while being connected to only one vertex.
We denote these vertices <span style="font-style:italic">p</span><sub>ℓ</sub>, <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub> with ℓ&lt;<span style="font-style:italic">k</span>.
This gives us the situation depicted in Figure <a href="#fig%3Aright%3Apath">??</a>.
Due to the order in which we added vertices to <span style="font-style:italic">Q</span>′, which is preserved by the removal of vertices when we go to <span style="font-style:italic">Q</span>, we know that any vertices in between <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span></sub> and <span style="font-style:italic">q</span><sub><span style="font-style:italic">j</span></sub> in <span style="font-style:italic">Q</span> must be one of the following:
</div><div class="minipage"><div class="center">
<img src="thesis038.png">
figureA hypothetical duplicate vertex.
<a id="fig:right:path"></a>
</div></div><ol class="enumerate" type=1><li class="li-enumerate">
Adjacent to <span style="font-style:italic">p</span><sub>ℓ</sub> and in the interval (<span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span></sub>, <span style="font-style:italic">p</span><sub>ℓ+1</sub>) in <span style="font-style:italic">p</span><sub>ℓ</sub>’s angular order.
</li><li class="li-enumerate">Adjacent to one of <span style="font-style:italic">p</span><sub>ℓ+1</sub>, <span style="font-style:italic">p</span><sub>ℓ+2</sub>,…, <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span>−1</sub> and to the right of <span style="font-style:italic">P</span>.
</li><li class="li-enumerate">Adjacent to <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub> and in the interval (<span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span>−1</sub>, <span style="font-style:italic">q</span><sub><span style="font-style:italic">j</span></sub>) in <span style="font-style:italic">p</span><sub><span style="font-style:italic">k</span></sub>’s angular order.
</li></ol><p>All three cases describe a vertex that lies in the interior of the cycle <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">i</span>+1</sub> … <span style="font-style:italic">p</span><sub><span style="font-style:italic">j</span></sub>. However, since <span style="font-style:italic">P</span> has no separating 2-chords on the right this cycle must be empty. Therefore, there are no vertices in between <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span></sub> and <span style="font-style:italic">q</span><sub><span style="font-style:italic">j</span></sub> and they must be subsequent duplicates. However, <span style="font-style:italic">Q</span> is a walk and <span style="font-style:italic">G</span> is simple so <span style="font-style:italic">Q</span> has no subsequent duplicates. Hence, <span style="font-style:italic">Q</span> contains no duplicates at all and is thus, by definition, a path.
</p><p><br>
</p><div class="theorem"><span style="font-weight:bold">Lemma 10</span>  <em>
</em><a id="lm:right:neighbourwalkNoInteriorVertex"></a><em>
The cycle </em><span style="font-style:italic">P</span> ⊕ ↼<span style="font-style:italic">Q</span><em> has no interior vertices.
</em></div><p><span style="font-weight:bold">Proof.</span>
In the construction of the right neighbor path both cases in Figure <a href="#fig%3Auni%3Awalkproof">??</a> add a triangle to the interior with all vertices of the triangle in <span style="font-style:italic">P</span> ⊕ ↼<span style="font-style:italic">Q</span>. Hence, the interior of <span style="font-style:italic">P</span> ⊕ ↼<span style="font-style:italic">Q</span> can be subdivided in a number triangles.
Suppose there is an interior vertex in the cycle <span style="font-style:italic">P</span> ⊕ ↼<span style="font-style:italic">Q</span>. Then the triangle containing this vertex is a separating triangle. Hence, <span style="font-style:italic">P</span> ⊕ ↼<span style="font-style:italic">Q</span> has no interior vertices.
</p><p><br>
</p><div class="theorem"><span style="font-weight:bold">Lemma 11</span>  <em>
</em><a id="lm:right:leftNeighborsOfTheRightNeighborPath"></a><em>
Every internal vertex </em><span style="font-style:italic">q</span><em> of a right neighbor path </em><span style="font-style:italic">Q</span><em> has a left neighbor.
</em></div><p><span style="font-weight:bold">Proof.</span>
Let <span style="font-style:italic">q</span> be an interior vertex of <span style="font-style:italic">Q</span>.
<span style="font-style:italic">q</span> Was added as right neighbor of some internal vertex <span style="font-style:italic">p</span> of <span style="font-style:italic">P</span>.
Since <span style="font-style:italic">Q</span> does not start or end at <span style="font-style:italic">p</span>, <span style="font-style:italic">p</span> must also be a left neighbor of <span style="font-style:italic">q</span> in <span style="font-style:italic">Q</span>.
</p><p><br>
</p><div class="theorem"><span style="font-weight:bold">Lemma 12</span>  <em>
</em><a id="lm:right:neighbourwalkChordFree"></a><em>
The left of a right neighbor path is chordfree.
</em></div><p><span style="font-weight:bold">Proof.</span>
Suppose that the right neighbor path <span style="font-style:italic">Q</span> = <span style="font-style:italic">q</span><sub>1</sub> … <span style="font-style:italic">q</span><sub><span style="font-style:italic">k</span></sub> has a chord on the left, say between <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span></sub> and <span style="font-style:italic">q</span><sub><span style="font-style:italic">j</span></sub> with <span style="font-style:italic">i</span>&lt; <span style="font-style:italic">j</span> −1 . Then <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">q</span><sub><span style="font-style:italic">j</span></sub> is an interior edge of <span style="font-style:italic">P</span> ⊕ ↼<span style="font-style:italic">Q</span>. There is a vertex <span style="font-style:italic">p</span><sub>ℓ</sub>∈ <span style="font-style:italic">P</span> such that <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span>+1</sub> is a right neighbor of <span style="font-style:italic">p</span><sub>ℓ</sub>, hence <span style="font-style:italic">p</span><sub>ℓ</sub><span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span>+1</sub> is an interior edge of <span style="font-style:italic">P</span> ⊕ ↼<span style="font-style:italic">Q</span>.
But now we have a crossing between <span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">q</span><sub><span style="font-style:italic">j</span></sub> and <span style="font-style:italic">p</span><sub>ℓ</sub><span style="font-style:italic">q</span><sub><span style="font-style:italic">i</span>+1</sub> since both edges run in the interior of <span style="font-style:italic">P</span> ⊕ ↼<span style="font-style:italic">Q</span> and their endpoints occur alternately in <span style="font-style:italic">P</span> ⊕ ↼<span style="font-style:italic">Q</span>.
See figure <a href="#fig%3Auni%3AneihbourwalkChordFree">??</a>.
Since we assume <span style="font-style:italic">G</span> is planar, there can be no chords on the left of the right neighbor path.
</p><p><br>
</p><p>  </p><p>  </p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
<img src="thesis039.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 24: The construction in the proof of Lemma <a href="#lm%3Aright%3AneighbourwalkChordFree">??</a>.</td></tr>
</table></div>
<a id="fig:uni:neihbourwalkChordFree"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote>
<!--TOC subsection id="sec9" Sweepcycle algorithm-->
<h3 id="sec9" class="subsection">5.2  Sweepcycle algorithm</h3><!--SEC END --><p>

<a id="ss:sweep"></a>
The first step of our algorithm is executing a sweepcycle algorithm inspired by, but different from, the sweepcycle algorithm by Fusy [<a href="#Fusy2006"></a>]. We use <span style="color:red"><span style="font-style:italic">C</span></span> to indicate the current sweep cycle. We shrink <span style="color:red"><span style="font-style:italic">C</span></span> by updating it with interior paths.
The algorithm finishes when <span style="color:red"><span style="font-style:italic">C</span></span> has no more interior vertices. When the algorithm finishes, it has produced a regular edge labeling.
One of the nicest things about the regular edge labeling is Lemma <a href="#lm%3Asweep%3ANoTwoSplitsAboveEachOther">??</a>.
This lemma states that we can not have the fan handle of a large topfan after a split vertex on a so-called bottom path.</p><p>During the algorithm we maintain several invariants on <span style="color:red"><span style="font-style:italic">C</span></span>. The first four are equivalent to those imposed by Fusy. The final invariant is new and allows us to prove Lemma <a href="#lm%3Asweep%3ANoTwoSplitsAboveEachOther">??</a>.</p>
<!--TOC paragraph id="sec10" Invariants -->
<h4 id="sec10" class="paragraph">Invariants </h4><!--SEC END --><ol class="enumerate" type=1><li class="li-enumerate">
=-4pt
<a id="i:uni:SWandSE"></a> The cycle <span style="color:red"><span style="font-style:italic">C</span></span> contains the two edges <span style="font-style:italic">S</span> <span style="font-style:italic">W</span> and <span style="font-style:italic">S</span> <span style="font-style:italic">E</span>.
</li><li class="li-enumerate"><a id="i:uni:noChords"></a> <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span>  has no chords.
</li><li class="li-enumerate"><a id="i:uni:intVertCond"></a> The inner vertex condition holds for all vertices in the exterior of <span style="font-style:italic">C</span>.
</li><li class="li-enumerate"><a id="i:uni:redOutgoing"></a> Every non-pole vertex on the sweepcycle has a red outgoing edge.
</li><li class="li-enumerate"><a id="i:uni:no2Chords"></a> <span style="color:red"><span style="font-style:italic">C</span></span>∖ <span style="font-style:italic">S</span>   has no separating 2-chords that do not use <span style="font-style:italic">S</span>.
</li></ol><p>We initialize the sweepcycle <span style="color:red"><span style="font-style:italic">C</span></span> with the outer cycle of Ḡ.
We denote the vertices of the sweepcycle <span style="color:red"><span style="font-style:italic">C</span></span> by <span style="font-style:italic">S</span>, <span style="font-style:italic">v</span><sub>1</sub> = <span style="font-style:italic">W</span>, <span style="font-style:italic">v</span><sub>2</sub>, … <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>−1</sub>, <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> = <span style="font-style:italic">E</span>, <span style="font-style:italic">S</span>.
We repeatedly consider the path <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span> .
In which case we order it from <span style="font-style:italic">W</span> to <span style="font-style:italic">E</span>. That the edges <span style="font-style:italic">S</span> <span style="font-style:italic">W</span> and <span style="font-style:italic">S</span> <span style="font-style:italic">E</span> are always in <span style="color:red"><span style="font-style:italic">C</span></span> is a result of Invariant <a href="#i%3Auni%3ASWandSE">??</a>.</p><p>Each update of the sweepcycle consists of the following three steps.
</p><ol class="enumerate" type=1><li class="li-enumerate">
=-4pt
Take the right neighbor walk of a subpath of <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span>  to get the <em>candidate path</em> <span style="font-style:italic">P</span>.
</li><li class="li-enumerate">Evade violating chords on <span style="font-style:italic">P</span> to get the <em>updating path</em> <span style="font-style:italic">P</span>′.
</li><li class="li-enumerate">Update the sweepcycle with <span style="font-style:italic">P</span>′.
</li></ol><p>We repeat these steps until the sweepcycle does not contain anymore interior vertices.
At that point we can terminate the algorithm by coloring the edges of the cycle <span style="color:red"><span style="font-style:italic">C</span></span> blue and its interior edges red.</p>
<!--TOC subsubsection id="sec11" Find the right neighbor path-->
<h4 id="sec11" class="subsubsection">5.2.1  Find the right neighbor path</h4><!--SEC END --><p>
Recall that we denote the vertices of <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span>  by <span style="font-style:italic">W</span> = <span style="font-style:italic">v</span><sub>1</sub> <span style="font-style:italic">v</span><sub>2</sub> … <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span>−1</sub> <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> = <span style="font-style:italic">E</span>.
Suppose they are all adjacent to <span style="font-style:italic">S</span>, then any vertex still in the interior of <span style="color:red"><span style="font-style:italic">C</span></span> would lie in a separating triangle of <span style="font-style:italic">G</span>. So we have no interior vertices and hence we can terminate the algorithm as described in Section <a href="#sss%3Aterminating">??</a>.
In the remainder we assume some vertices from <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span>  are not adjacent to <span style="font-style:italic">S</span>.</p><p>Since <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span>  has some vertices incident to <span style="font-style:italic">S</span> (at least <span style="font-style:italic">W</span> and <span style="font-style:italic">E</span>) and some that are not, we can consider maximal subpaths of <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span>  consisting of vertices adjacent to <span style="font-style:italic">S</span>.
We denote by <span style="font-style:italic">v</span><sub><span style="font-style:italic">i</span></sub> the last vertex of first maximal subpath of vertices adjacent to <span style="font-style:italic">S</span> and by <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span></sub> the first vertex of the second maximal subpath.
As candidate path <span style="font-style:italic">P</span> we take the right neighbor path of <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span> |<sub><span style="font-style:italic">v</span><sub><span style="font-style:italic">i</span></sub>, <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span></sub></sub>. This right neighbor path does indeed exist since all internal vertices of <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span> |<sub><span style="font-style:italic">v</span><sub><span style="font-style:italic">i</span></sub>, <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span></sub></sub> are interior vertices of <span style="font-style:italic">G</span> and <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span>  has no violating chords by Invariants <a href="#i%3Auni%3AnoChords">??</a> and <a href="#i%3Auni%3Ano2Chords">??</a>.
This situation is depicted in Figure <a href="#fig%3Asweep%3AnoIrregularity">??</a>.</p>
<!--TOC subsubsection id="sec12" Evading violating chords-->
<h4 id="sec12" class="subsubsection">5.2.2  Evading violating chords</h4><!--SEC END --><p>
Recall that a violating chords on the candidate path <span style="font-style:italic">P</span> can be one of the following two things:
</p><ol class="enumerate" type=1><li class="li-enumerate">
=-4pt
Chords
</li><li class="li-enumerate">Separating 2-chords
</li></ol><p>The <em>middle</em> vertex of a 2-chord is the only internal vertex of that 2-chord (seen as a path).
All violating chords are on the right of the candidate path due to Lemma <a href="#lm%3Aright%3AneighbourwalkChordFree">??</a> (no chords on the left) and Lemma <a href="#lm%3Aright%3AneighbourwalkNoInteriorVertex">??</a> (no separating 2-chords on the left).</p><p>Before we can show how to evade these structures, we first introduce more notation. We orient <span style="font-style:italic">P</span> from <span style="font-style:italic">v</span><sub><span style="font-style:italic">i</span></sub> ∈ <span style="color:red"><span style="font-style:italic">C</span></span> (the vertex closest to <span style="font-style:italic">W</span>) to <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span></sub> ∈ <span style="color:red"><span style="font-style:italic">C</span></span> (the vertex closest to <span style="font-style:italic">E</span>) and denote its vertices by <span style="font-style:italic">p</span><sub>1</sub> … <span style="font-style:italic">p</span><sub><span style="font-style:italic">r</span></sub>.
The <em>index</em> of a vertex <span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span></sub> ∈ <span style="font-style:italic">P</span> is its position in the path, that is, the index of <span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span></sub> is <span style="font-style:italic">m</span>.
The <em>start index</em> of a violating chord <span style="font-style:italic">C</span> is the index of the first vertex in <span style="font-style:italic">P</span> that is also in <span style="font-style:italic">C</span>. Similarly, the <em>end index</em> is the index of the last vertex in <span style="font-style:italic">P</span> that is also in <span style="font-style:italic">C</span>.
The <em>range</em> of a violating chord is given by its start and end index. We update the sweepcycle with some <em>update path</em> <span style="font-style:italic">P</span>′, depending on the violating chords we find on the candidate path <span style="font-style:italic">P</span>. This update is described in Section <a href="#sss%3Asweep%3Aupdate">??</a>.</p><p>While describing how the updating path <span style="font-style:italic">P</span> depends on the violating chords of <span style="font-style:italic">P</span>, we show that the following two lemmas hold in every case.</p><div class="theorem"><span style="font-weight:bold">Lemma 14</span>  <em>
The updating path has no violating chords
</em><a id="lm:sweep:augNoIregularity"></a><em>
</em></div><div class="theorem"><span style="font-weight:bold">Lemma 15</span>  <em>
</em><a id="lm:sweep:noConnectingIregularity"></a><em>
There are no violating chords, not containing </em><span style="font-style:italic">S</span><em> as middle vertex, with one endpoint on the sweepcycle </em><span style="color:red"><span style="font-style:italic">C</span></span><em> and one endpoint on the updating path </em><span style="font-style:italic">P</span>′<em>.
</em></div><p><span style="font-weight:bold">We have no violating chord.</span>
When <span style="font-style:italic">P</span> has no violating chords, we update the sweepcycle with the entire candidate path <span style="font-style:italic">P</span>.
In this case the update path <span style="font-style:italic">P</span>′ is equal to <span style="font-style:italic">P</span>.</p><p><span style="font-style:italic">P</span>′ has no violating chord by the definition of this case. Moreover, there are no violating chords with one endpoint on <span style="font-style:italic">P</span>′ and one endpoint on <span style="color:red"><span style="font-style:italic">C</span></span> since <span style="font-style:italic">v</span><sub><span style="font-style:italic">i</span></sub> and <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span></sub> are both adjacent to <span style="font-style:italic">S</span>, so we can not have any chords and any 2-chords must have <span style="font-style:italic">S</span> as middle vertex.
</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
<img src="thesis040.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 25: Updating path when <span style="font-style:italic">P</span> contains no violating chord.</td></tr>
</table></div>
<a id="fig:sweep:noIrregularity"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><p><span style="font-weight:bold">We have a chord on </span><span style="font-weight:bold"><span style="font-style:italic">P</span></span><span style="font-weight:bold">.</span>
Note that we can not have a chord incident to one of the exterior vertices of the candidate path <span style="font-style:italic">P</span>, that is <span style="font-style:italic">p</span><sub>1</sub> or <span style="font-style:italic">p</span><sub><span style="font-style:italic">r</span></sub>, since any such chord would violate Invariant <a href="#i%3Auni%3Ano2Chords">??</a> of <span style="color:red"><span style="font-style:italic">C</span></span> as can be seen in Figure <a href="#fig%3Asweep%3AnoChordOnExteriorVertex">??</a>.</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
<img src="thesis041.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 26: Hypothetical situation where <span style="font-style:italic">P</span> would have a chord on an exterior vertex.</td></tr>
</table></div>
<a id="fig:sweep:noChordOnExteriorVertex"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><p>We identify the chords by their ranges. Of the chords with the smallest end index <span style="font-style:italic">m</span> we consider the one with the largest start index <span style="font-style:italic">n</span>. We denote this chord by <span style="font-style:italic">C</span>.
Note that this chord can not contain any other chords since such a chord would have either a large start index or a smaller end index.
The way in which we find this chord <span style="font-style:italic">C</span> is illustrated in Figure <a href="#fig%3Asweep%3AchordsOnCandidatePath">??</a>.</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
<img src="thesis042.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 27: Finding the chord <span style="font-style:italic">C</span>.</td></tr>
</table></div>
<a id="fig:sweep:chordsOnCandidatePath"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><p>What we do now depends on whether a separating 2-chord shows up in the interior of the chord concatenated to the candidate path <span style="font-style:italic">P</span>|<sub><span style="font-style:italic">m</span>, <span style="font-style:italic">n</span></sub> ⊕ ↼<span style="font-style:italic">C</span>.</p><p><em>No separating 2-chord.</em>
If there is no separating 2-chord in the interior of <span style="font-style:italic">P</span>|<sub><span style="font-style:italic">i</span>, <span style="font-style:italic">j</span></sub> ⊕ ↼<span style="font-style:italic">C</span>, we let <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> be the shared neighbor in <span style="color:red"><span style="font-style:italic">C</span></span> of <span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span></sub> and <span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span> +1</sub> and we let <span style="font-style:italic">v</span><sub>ℓ</sub> the shared neighbor in <span style="color:red"><span style="font-style:italic">C</span></span> of <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span> −1</sub> and <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub>.
The updating path <span style="font-style:italic">P</span>′ is the right neighbor path of <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span> |<sub><span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>, <span style="font-style:italic">v</span><sub>ℓ</sub></sub>.
See Figure <a href="#fig%3Asweep%3AchordUpdate">??</a>.</p><p><span style="font-style:italic">P</span>′ is entirely inside a chord containing no more chords and thus can not contain a chord.
Moreover, there are no separating 2-chords on <span style="font-style:italic">P</span>|<sub><span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span></sub>, <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub></sub> so <span style="font-style:italic">P</span>′ can not have separating 2-chords.
So Lemma <a href="#lm%3Asweep%3AaugNoIregularity">??</a> holds in this case.
Any violating chord with one endpoint in <span style="font-style:italic">P</span>′ and one in <span style="color:red"><span style="font-style:italic">C</span></span> has to cross <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span></sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">v</span><sub>ℓ</sub> so we can not have a chord and any 2-chord has <span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span></sub> or <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> as middle vertex.
But, with this restriction such a 2-chord can not be separating.
So Lemma <a href="#lm%3Asweep%3AnoConnectingIregularity">??</a> also holds in this case.</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
<img src="thesis043.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 28: Updating path when <span style="font-style:italic">P</span> has a chord not containing a separating 2-chord.</td></tr>
</table></div>
<a id="fig:sweep:chordUpdate"></a>
<img src="thesis044.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 29: Updating path when <span style="font-style:italic">P</span> has a chord containing at least one separating 2-chord.</td></tr>
</table></div>
<a id="fig:sweep:2chordInChordUpdate"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><p><em>At least one separating 2-chord.</em>
Let <span style="font-style:italic">n</span>′ be end index of the separating 2-chord with the lowest end index in the interior of <span style="font-style:italic">P</span>|<sub><span style="font-style:italic">m</span>, <span style="font-style:italic">n</span></sub> ⊕ ↼<span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span></sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub>. And let <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> be the shared neighbor on the sweepcycle of <span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span></sub> and <span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span> +1</sub> and let <span style="font-style:italic">v</span><sub>ℓ</sub> and <span style="font-style:italic">v</span><sub>ℓ′</sub> be the shared neighbor on the sweepcycle of <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span> −1</sub> and <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> and of <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span>′ −1</sub> and <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span>′</sub>, respectively.
Then the updating path <span style="font-style:italic">P</span>′ is the right neighbor path of <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span> |<sub><span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>, <span style="font-style:italic">v</span><sub>ℓ′</sub></sub>. See Figure <a href="#fig%3Asweep%3A2chordInChordUpdate">??</a>.</p><p><span style="font-style:italic">P</span>′ is entirely inside a chord containing no more chords and thus can not contain a chord. Moreover, <span style="font-style:italic">P</span>′ can not have a separating 2-chord since we evaded the end of the first one ending.
Just as in the above case we can not have any violating chord with one endpoint in <span style="font-style:italic">P</span>′ and one in <span style="color:red"><span style="font-style:italic">C</span></span> outside the containing chord <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span></sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">v</span><sub>ℓ</sub>⊕ ↼<span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span> |<sub><span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>, <span style="font-style:italic">v</span><sub>ℓ</sub></sub>.
That leaves violating chords with the second endpoint inside the containing chord <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span></sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">v</span><sub>ℓ</sub>⊕ ↼<span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span> |<sub><span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>, <span style="font-style:italic">v</span><sub>ℓ</sub></sub>.
Suppose that we have a separating 2-chord, then this would have been a chord of <span style="font-style:italic">P</span>. This is in contradiction with <span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span></sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> being a minimal chord.
We also can not have a chord since this would break the cycle <span style="font-style:italic">P</span>|<sub><span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span></sub>, <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub></sub> ⊕ <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span></sub> .</p><p><span style="font-weight:bold">Only separating 2-chords.</span>
In this case the candidate path <span style="font-style:italic">P</span> has no chords, otherwise we would be in the above case. We split this case into two subcases, either we have a separating 2-chord with <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span></sub> as end vertex or we have only other separating 2-chords.</p><p><em>Any separating 2-chords with </em><span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span></sub><em> as end vertex.</em>
We find the smallest separating 2-chord with <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span></sub> as end vertex (i.e. the one with the highest start index). Say this separating 2-chord has start index <span style="font-style:italic">m</span>.
Let <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> be the shared neighbor on the sweepcycle of <span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span></sub> and <span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span> +1</sub>. The updating path is the right neighbor path of <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span> |<sub><span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>, <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span></sub></sub>. See Figure <a href="#fig%3Asweep%3ApEBound">??</a>.</p><p><span style="font-style:italic">P</span>′ starts inside the separating 2-chord adjacent to <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span></sub> with the highest start index. <span style="font-style:italic">P</span>′ has no chords since <span style="font-style:italic">P</span> already had none.
However, <span style="font-style:italic">P</span>′ can have separating 2-chords that are not adjacent to <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span></sub>.
If this is the case, we find the 2-chord with the lowest end index <span style="font-style:italic">n</span>.
Let <span style="font-style:italic">v</span><sub>ℓ</sub> be the shared neighbor on the sweepcycle of <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> and <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span>−1</sub>.
The updating path is the right neighbor path of <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span> |<sub><span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub>, <span style="font-style:italic">v</span><sub>ℓ</sub></sub>.</p><p>We have no chords with one endpoint in <span style="font-style:italic">P</span>′ and one in <span style="color:red"><span style="font-style:italic">C</span></span> since these would have to break <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span></sub> <span style="font-style:italic">x</span> <span style="font-style:italic">p</span><sub><span style="font-style:italic">m</span></sub> <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> ⊕ ↼<span style="font-style:italic">P</span>′ or be adjacent to <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span></sub>, which is in violation of Invariant <a href="#i%3Auni%3Ano2Chords">??</a>.
Any 2-chords with one endpoint in <span style="font-style:italic">P</span>′ and one in <span style="color:red"><span style="font-style:italic">C</span></span> would have <span style="font-style:italic">x</span> or any vertex in <span style="font-style:italic">P</span> as middle vertex.
However, the first yields a 2-chord of the candidate path with a higher start range, this is a contradiction.
And the second gives a chord of <span style="font-style:italic">P</span>, this is in contradiction with the current case where <span style="font-style:italic">P</span> has no chords.</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
<img src="thesis045.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 30: Updating path when <span style="font-style:italic">P</span> has a separating 2-chord with <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span></sub> as end vertex.</td></tr>
</table></div>
<a id="fig:sweep:pEBound"></a>
<img src="thesis046.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 31: Updating path when <span style="font-style:italic">P</span> has separating 2-chords none of which have <span style="font-style:italic">v</span><sub><span style="font-style:italic">j</span></sub> as end vertex.</td></tr>
</table></div>
<a id="fig:sweep:free2chord"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><p><em>Only other separating 2-chords</em>
Find the 2-chord with the lowest end index, say that this is <span style="font-style:italic">n</span>.
Let <span style="font-style:italic">v</span><sub>ℓ</sub> be the shared neighbor on the sweepcycle of <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> and <span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span>−1</sub>.
The updating path is the right neighbor path of <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span> |<sub><span style="font-style:italic">v</span><sub><span style="font-style:italic">i</span></sub>, <span style="font-style:italic">v</span><sub>ℓ</sub></sub>. See Figure <a href="#fig%3Asweep%3Afree2chord">??</a>.</p><p>Any updating path stops before the end of a separating 2-chord and furthermore contains no chords since <span style="font-style:italic">P</span> already did not.</p><p>Any violating chord with one vertex in the updating path and the other on the old sweepcycle must end to the right of the updating path since the updating path starts at <span style="font-style:italic">v</span><sub><span style="font-style:italic">i</span></sub>, a vertex adjacent to <span style="font-style:italic">S</span>.
Suppose that we have a separating 2-chord then that would have been a chord of the candidate path. This is in contradiction with the assumption that the candidate path had no chords.
We also have no chord since such a chord would violate Invariant <a href="#i%3Auni%3Ano2Chords">??</a> of the old sweepcycle. Furthermore, the second-to-last vertex of the updating path has no chords since it would break <span style="font-style:italic">v</span><sub>ℓ</sub><span style="font-style:italic">p</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">x</span> <span style="font-style:italic">p</span><sub><span style="font-style:italic">u</span></sub>. (see Figure <a href="#fig%3Asweep%3Afree2chord">??</a>).</p>
<!--TOC subsubsection id="sec13" Updating-->
<h4 id="sec13" class="subsubsection">5.2.3  Updating</h4><!--SEC END --><p>
<a id="sss:sweep:update"></a>
Once we found the updating path <span style="font-style:italic">P</span>′, we can update the sweepcycle with this path. Let <span style="font-style:italic">p</span><sub><span style="font-style:italic">a</span></sub> and <span style="font-style:italic">p</span><sub><span style="font-style:italic">b</span></sub> indicate the two unique vertices of <span style="font-style:italic">P</span>′ that are also part of <span style="color:red"><span style="font-style:italic">C</span></span>. We then let <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span> |<sub><span style="font-style:italic">P</span>′</sub> denote the path <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span> |<sub><span style="font-style:italic">p</span><sub><span style="font-style:italic">a</span></sub>, <span style="font-style:italic">p</span><sub><span style="font-style:italic">b</span></sub></sub>.
In this section we describe how to update the sweepcycle with an updating path and we show that the update maintains all sweepcycle invariants (Lemma <a href="#lm%3Asweep%3AupdateMaintainsInvariants">??</a>).
To execute the update we color all interior edge of <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span> |<sub><span style="font-style:italic">P</span>′</sub> ⊕ ↼<span style="font-style:italic">P</span>′ red and orient them towards <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span> |<sub><span style="font-style:italic">P</span>′</sub>.
We also color all edges of <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span> |<sub><span style="font-style:italic">P</span>′</sub> blue and orient them from the lower to the higher indices.
We then update the sweepcycle to <span style="color:red"><span style="font-style:italic">C</span></span>′ by replacing <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span> |<sub><span style="font-style:italic">P</span>′</sub> by <span style="font-style:italic">P</span>′ in <span style="color:red"><span style="font-style:italic">C</span></span>.
An example of the whole update for an updating path <span style="font-style:italic">P</span>′ can be seen in Figure <a href="#fig%3Asweep%3Aupdate">??</a>.</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
[b]0.45 @percent
<img src="thesis047.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 32: Before.</td></tr>
</table></div>

 
[b]0.45 @percent
<img src="thesis048.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 33: After.</td></tr>
</table></div>

	<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 34: The update.</td></tr>
</table></div>
<a id="fig:sweep:update"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><div class="theorem"><span style="font-weight:bold">Lemma 16</span>  <em>
</em><a id="lm:sweep:updateMaintainsInvariants"></a><em>
Updating with a path </em><span style="font-style:italic">P</span>′<em> maintains all sweepcycle invariants.
</em></div><p><span style="font-weight:bold">Proof.</span>
Invariant <a href="#i%3Auni%3ASWandSE">??</a> remains true. Invariant <a href="#i%3Auni%3AintVertCond">??</a> holds due to the way we colored the edges around the new interior vertices as can be seen in Figure <a href="#fig%3Asweep%3Aupdate">??</a>.
Furthermore, Invariant <a href="#i%3Auni%3AredOutgoing">??</a> holds because every internal vertex of <span style="font-style:italic">P</span>′ has a left neighbor by Lemma <a href="#lm%3Aright%3AleftNeighborsOfTheRightNeighborPath">??</a>.</p><p>To see that Invariants <a href="#i%3Auni%3AnoChords">??</a> and <a href="#i%3Auni%3Ano2Chords">??</a> hold, note that there can be no violating chords with both endpoints in the overlap of the old and new sweepcycle <span style="color:red"><span style="font-style:italic">C</span></span> ∩ <span style="color:red"><span style="font-style:italic">C</span></span>′ by Invariants <a href="#i%3Auni%3AnoChords">??</a> and <a href="#i%3Auni%3Ano2Chords">??</a>.
Since the updating path itself also has no violating chords (Lemma <a href="#lm%3Asweep%3AaugNoIregularity">??</a>),
we know any violating chord <span style="font-style:italic">C</span> has to have one vertex on <span style="color:red"><span style="font-style:italic">P</span></span> and one vertex on the unchanged part of old sweepcycle <span style="color:red"><span style="font-style:italic">C</span></span> ∩ <span style="color:red"><span style="font-style:italic">C</span></span>′.
However, these potential chords can not exist by Lemma <a href="#lm%3Asweep%3AnoConnectingIregularity">??</a>.
Hence, <span style="color:red"><span style="font-style:italic">C</span></span>′ is a valid new sweepcycle.
</p><p><br>
</p><p>If after the update the new sweepcycle <span style="color:red"><span style="font-style:italic">C</span></span>′ has no interior vertices, we terminate the algorithm; this is described in Section <a href="#sss%3Aterminating">??</a>.
Otherwise, we start the update loop again by finding a new candidate path.</p>
<!--TOC subsubsection id="sec14" Terminating the algorithm-->
<h4 id="sec14" class="subsubsection">5.2.4  Terminating the algorithm</h4><!--SEC END --><p>
<a id="sss:terminating"></a>
When the sweepcycle has no more interior vertices, we can not update it anymore.
However, at this point it is easy to color the remainder of the graph.
All vertices in <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span>  must be adjacent to <span style="font-style:italic">S</span> since <span style="font-style:italic">S</span> <span style="font-style:italic">W</span> and <span style="font-style:italic">S</span> <span style="font-style:italic">E</span> are part of <span style="color:red"><span style="font-style:italic">C</span></span> by Invariant <a href="#i%3Auni%3ASWandSE">??</a>, <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span>  has no chords by Invariant <a href="#i%3Auni%3AnoChords">??</a> and <span style="color:red"><span style="font-style:italic">C</span></span> does not contain any interior vertices.
All sweepcycle interior edges are adjacent to <span style="font-style:italic">S</span>, since otherwise we would have a chord in <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span>  (violating Invariant <a href="#i%3Auni%3AnoChords">??</a>).</p><p>We color all interior edges of <span style="color:red"><span style="font-style:italic">C</span></span> red and orient them towards <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span>  and the edges in <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">S</span>  are colored blue and oriented towards <span style="font-style:italic">E</span>. The termination step can be seen in Figure <a href="#fig%3Asweep%3Aterminate">??</a>. This last move completes the interior vertex condition for vertices in <span style="color:red"><span style="font-style:italic">C</span></span> ∖ <span style="font-style:italic">W</span>, <span style="font-style:italic">S</span>, <span style="font-style:italic">E</span>   and also correctly completes the exterior vertex condition.</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
[b]0.45 @percent
<img src="thesis049.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 35: Before.</td></tr>
</table></div>

 
[b]0.45 @percent
<img src="thesis050.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 36: After.</td></tr>
</table></div>

<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 37: The termination step.</td></tr>
</table></div>
<a id="fig:sweep:terminate"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><div class="theorem"><span style="font-weight:bold">Lemma 17</span>  <em>
</em><a id="lm:sweep:REL"></a><em>
The resulting structure is a regular edge labeling
</em></div><p><span style="font-weight:bold">Proof.</span>
After running the whole algorithm the interior vertex condition holds for all vertices in the graph by Invariant <a href="#i%3Auni%3AintVertCond">??</a>. Furthermore, the poles are also colored correctly due to Invariant <a href="#i%3Auni%3ASWandSE">??</a>.
</p><p><br>
</p>
<!--TOC subsubsection id="sec15" A useful property of this regular edge labelling-->
<h4 id="sec15" class="subsubsection">5.2.5  A useful property of this regular edge labelling</h4><!--SEC END --><p>
There still is a useful property of this regular edge labeling left to discuss (Lemma <a href="#lm%3Asweep%3ANoTwoSplitsAboveEachOther">??</a>). Before we can state this property, we first need to introduce fans.</p><p><span style="font-weight:bold">Fans.</span>
We want to better describe the interior of blue (or red) faces. Every interior edge of such face goes from one boundary path to the other (otherwise its start or end vertex would violate the interior vertex condition or create a face with a boundary path of length one violating Observation <a href="#obs%3Arel%3AnoBpOfLength1">??</a>). We now describe the edges from the split vertex to the merge vertex of <span style="font-style:italic">F</span>.</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
<img src="thesis051.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 38: An example face with fans.</td></tr>
</table></div>
<a id="fig:uni:fans"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><p>Let <span style="font-style:italic">u</span><sub>0</sub> , <span style="font-style:italic">u</span><sub>1</sub>, … <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> be the vertices of the top boundary path of <span style="font-style:italic">F</span> and <span style="font-style:italic">v</span><sub>0</sub>, <span style="font-style:italic">v</span><sub>1</sub>, …, <span style="font-style:italic">v</span><sub><span style="font-style:italic">m</span></sub> the vertices of the bottom boundary path.
That is <span style="font-style:italic">u</span><sub>0</sub>=<span style="font-style:italic">v</span><sub>0</sub> is the split vertex and <span style="font-style:italic">u</span><sub><span style="font-style:italic">n</span></sub> = <span style="font-style:italic">v</span><sub><span style="font-style:italic">m</span></sub> is the merge vertex.
Since our graph is a triangulation, <span style="font-style:italic">u</span><sub>1</sub><span style="font-style:italic">v</span><sub>1</sub> must be an edge.
For the second edge in the face we have two options, either <span style="font-style:italic">u</span><sub>1</sub><span style="font-style:italic">v</span><sub>2</sub> or <span style="font-style:italic">u</span><sub>2</sub><span style="font-style:italic">v</span><sub>1</sub>, otherwise this edge and the previous one would not form a triangle.
This argument holds for every subsequent edge, we can either increase the index of the top boundary path or the index of the bottom boundary path.
Hence, this face is, for the readers that know this term, a <em>triangle strip</em>.</p><p>r7cm
<img src="thesis052.png">
A number of fan-related terms.
<a id="fig:rect:fanTerms"></a>
</p><p>We call a maximal sequence of at least two edges increasing the index on the top boundary path (and thus keeping the index on the upper path fixed) a <em>bottomfan</em> and a maximal sequence of at least two edges increasing the index on the bottom boundary path is called a <em>topfan</em>.
The <em>size</em> of such a fan is the number of edges contained in the sequence. By the definition of a fan it has size of at least 2.
We use <em>fans</em> to refer to both these <em>types</em> of fans (i.e. topfans and bottomfans).
We call a fan of size 3 or larger a <em>large fan</em> and a fan of size 2 a <em>small fan</em>.</p><p>The <em>left</em> of the fan is the part closest to the split vertex and the <em>right</em> of the fan is the part closest to the merge vertex.</p><p>In faces we alternately encounter bottomfans and topfans. If we would have two adjacent fans of the same type, we would just have a single larger fan of that type.
In Figure <a href="#fig%3Auni%3Afans">??</a> we see a blue face consisting of subsequently a bottomfan of size 3, a topfan of size 2, a bottomfan of size 2, a topfan of size 6, a bottomfan of size 3 and a topfan of size 3.</p><p>We introduce some more terminology for fans: <em>outer edges</em>, <em>fan handles</em> and the <em>rim</em> as can be seen in Figure <a href="#fig%3Arect%3AfanTerms">??</a>. The <em>fan handle</em> <span style="font-style:italic">v</span> is the vertex shared by all edges in the fan. Let <span style="font-style:italic">H</span> be the induced subgraph of vertices incident to the edges in the fan. <span style="font-style:italic">H</span> contains no edges not belonging to <span style="font-style:italic">F</span> since these would lead to separating 3-cycles. The <em>rim</em> is the path given by <span style="font-style:italic">F</span>∖ <span style="font-style:italic">v</span>  .
The <em>outer rim</em> are the two extreme edges of this path and the <em>outer edges</em> are the edges between the fan handles and the extreme vertices of the <em>rim</em>.</p><p>A similar discussion can be given for red faces. However, then we have <em>right fans</em> and <em>left fans</em> instead of bottom and top fans.</p><p><span style="font-weight:bold">The property.</span></p><p>!r5cm
<img src="thesis053.png">
The bottom path of this splitvertex is given in bold.
<a id="fig:sweep:bottomPath"></a>
</p><p>Before finally discussing the property, we introduce one more definition.
Recall a <em>splitvertex</em> is a vertex with more than one outgoing blue edge.
Given a splitvertex <span style="font-style:italic">v</span>, the <em>bottom</em> path is the path that comes in through the first edge in the interval of incoming blue edges in the rotation at <span style="font-style:italic">v</span> and leaves through the last edge in the interval of outgoing blue edge in the rotation at <span style="font-style:italic">v</span>.
See Figure <a href="#fig%3Asweep%3AbottomPath">??</a>.</p><div class="theorem"><span style="font-weight:bold">Lemma 18</span>  <em>
</em><a id="lm:sweep:NoTwoSplitsAboveEachOther"></a><em>
Let </em><span style="font-style:italic">v</span><em> be any splitvertex. Then the subsequent vertex on the bottom path </em><span style="font-style:italic">w</span><em> can not be the handle of a large topfan.
</em></div><p><span style="font-weight:bold">Proof.</span>
There are two possible causes of <span style="font-style:italic">v</span> being a splitvertex, <span style="font-style:italic">v</span> is either adjacent to <span style="font-style:italic">S</span> or <span style="font-style:italic">v</span> is a splitvertex due to a chord.</p><p>If <span style="font-style:italic">v</span> is a splitvertex because it is adjacent to <span style="font-style:italic">S</span>, then since <span style="font-style:italic">w</span> is on the bottom path it also has to be adjacent to <span style="font-style:italic">S</span> by the definition of the bottom path.
Hence, <span style="font-style:italic">w</span> is not the handle of a large topfan.</p><p>If <span style="font-style:italic">v</span> is a splitvertex due to a chord <span style="font-style:italic">v</span> <span style="font-style:italic">a</span> <span style="font-style:italic">b</span> <span style="font-style:italic">x</span>, we can continue the bottom path past <span style="font-style:italic">w</span> as a bottom path that eventually goes to <span style="font-style:italic">x</span> since every chord is evaded by a single path from <span style="font-style:italic">v</span><sub><span style="font-style:italic">k</span></sub> to <span style="font-style:italic">v</span><sub>ℓ</sub> in the algorithm.
We denote this extended bottom path by <span style="color:red"><span style="font-style:italic">P</span></span>.
The situation is depicted in Figure <a href="#fig%3Asweep%3AbotomPathChord">??</a>.</p><p>The interior of <span style="font-style:italic">vabx</span> ⊕ ↼<span style="color:red"><span style="font-style:italic">P</span></span> has no vertices. Suppose there would be such a vertex . Then, since <span style="color:red"><span style="font-style:italic">P</span></span> is a bottom path the blue path going through this vertex has to start at <span style="font-style:italic">a</span> and end at <span style="font-style:italic">b</span>. But this gives a blue face with only one edge on its bottom boundary path violating Observation <a href="#obs%3Arel%3AnoBpOfLength1">??</a>. Since our graph is a regular edge labeling, <span style="font-style:italic">vabx</span> ⊕ ↼<span style="color:red"><span style="font-style:italic">P</span></span> has no interior vertices.</p><p>This also implies all interior edges are red (by the definition of bottom path) and thus that <span style="font-style:italic">ab</span> is blue otherwise we would get a monochromatic triangle.</p><p>Now <span style="font-style:italic">w</span> can not be connected to any vertex in <span style="color:red"><span style="font-style:italic">P</span></span> since that would again give a face with a boundary path of length 1 by Observation <a href="#obs%3Arel%3AnoBpOfLength1">??</a>.
So <span style="font-style:italic">w</span> can only be connected to <span style="font-style:italic">a</span> and <span style="font-style:italic">b</span> and is thus a topfan of size at most 2.
(If it is a topfan at all, since we do not consider topfans of size 1 as topfans.)
</p><p><br>
</p><p>    </p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
<img src="thesis054.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 39: The situation in the proof of Lemma <a href="#lm%3Asweep%3ANoTwoSplitsAboveEachOther">??</a>.</td></tr>
</table></div>
<a id="fig:sweep:botomPathChord"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><!--TOC subsection id="sec16" Flipping Blue <span style="font-style:italic">Z</span>’s-->
<h3 id="sec16" class="subsection">5.3  Flipping Blue <span style="font-weight:bold"><span style="font-style:italic">Z</span></span>’s</h3><!--SEC END --><p>

<a id="ss:flipBlueZ"></a></p><p>The regular edge labeling provided by the sweepcycle algorithm of Section <a href="#ss%3Asweep">??</a> is often vertically one-sided but I have not succeeded in proving that this is always the case.
We would prefer to get a vertically one-sided regular edge labeling since if we then recolor edges to subdivide large blue faces it is harder to accidentally create many-sided vertical segments.
In this section we modify the current regular edge labeling to make it vertically one-sided while maintaining the property of Lemma <a href="#lm%3Asweep%3ANoTwoSplitsAboveEachOther">??</a>.</p><p>A <em>blue </em><span style="font-style:italic">Z</span> is a path of three blue edges all in the same red face. A <span style="font-style:italic">Z</span> has a <em>middle</em> edge, this is the second edge in this path.
If the current regular edge labeling is not one-sided there must be a blue <span style="font-style:italic">Z</span> as is shown in Lemma <a href="#lm%3Azflip%3AblueZNorVertOneSided">??</a>.
</p><div class="theorem"><span style="font-weight:bold">Lemma 19</span>  <em>
</em><a id="lm:zflip:blueZNorVertOneSided"></a><em>
A regular edge labeling is not one sided if and only if it contains a blue </em><span style="font-style:italic">Z</span><em>
</em></div><p><span style="font-weight:bold">Proof.</span>
Consider a regular edge labeling that is not one-sided, then it contains a red face of which both boundary paths are of length at least 3.
However, since the interior faces of <span style="font-style:italic">G</span> are triangles there must then be a blue <span style="font-style:italic">Z</span> in this face.</p><p>If a face contains a blue <span style="font-style:italic">Z</span>, it can not be one-sided. Since path of length 3 inside a red face must have at least 2 vertices on both boundary paths.
</p><p><br>
</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
<img src="thesis055.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 40: The two possible blue <span style="font-style:italic">Z</span>’s.</td></tr>
</table></div>
<a id="fig:zflip:blueZ"></a>
<img src="thesis056.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 41: The flip.</td></tr>
</table></div>
<a id="fig:zflip:flip"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><p>As long as the regular edge labeling is not vertically one-sided we find such a blue <span style="font-style:italic">Z</span> and recolor its middle edge as in Figure <a href="#fig%3Azflip%3Aflip">??</a>. We call this a <em>flip</em> and we will say that this edge is <em>flipped</em>.
Note that both flips transfer a valid regular edge labeling to another valid regular edge labeling. If the interior vertex condition was fulfilled in Figure <a href="#fig%3Azflip%3AblueZ">??</a> then it is also fulfilled in Figure <a href="#fig%3Azflip%3Aflip">??</a>.</p><p>We repeat these flips until the regular edge labeling is vertically one-sided.
Since every flip reduces the number of blue edges by one, this is a finite procedure.</p><div class="theorem"><span style="font-weight:bold">Lemma 20</span>  <em>
</em><a id="lm:sweep:vertOnsided"></a><em>
The result is a vertically one-sided rectangular edge labeling.
</em></div><p><span style="font-weight:bold">Proof.</span>
We still have a regular edge labeling since the flips maintain a regular edge labeling.
By construction, we flip all blue <span style="font-style:italic">Z</span>’s. If we do not have anymore <span style="font-style:italic">Z</span>’s then the remaining regular edge labeling is vertically one-sided by Lemma <a href="#lm%3Azflip%3AblueZNorVertOneSided">??</a>.
</p><p><br>
</p><div class="theorem"><span style="font-weight:bold">Lemma 21</span>  <em>
</em><a id="lm:zflip:NoTwoSplitsAboveEachOtherVertOnesided"></a><em>
Let </em><span style="font-style:italic">v</span><em> be any splitvertex. Then the subsequent vertex on the bottom path </em><span style="font-style:italic">w</span><em> can not be the handle of a large topfan.
</em></div><p><span style="font-weight:bold">Proof.</span>
This is the same statement as in Lemma <a href="#lm%3Asweep%3ANoTwoSplitsAboveEachOther">??</a>. We will show that the operation of flipping <span style="font-style:italic">Z</span>’s does not compromise the validity of this statement.</p><p>The flips in this section can only reduce the number of split vertices.
Hence it suffices, to show that the statement still holds for all previously existing split vertices.</p><p>For a split vertex <span style="font-style:italic">v</span> adjacent to <span style="font-style:italic">S</span> we can note that the edge <span style="font-style:italic">vw</span> will not be flipped because it can not be a middle edge.
Hence, <span style="font-style:italic">w</span> is still on the bottom path and still not the handle of a big topfan.</p><p>If <span style="font-style:italic">v</span> is a split vertex due to a chord the edges of <span style="color:red"><span style="font-style:italic">P</span></span> and <span style="font-style:italic">ab</span> in Figure <a href="#fig%3Asweep%3AbotomPathChord">??</a> can not have been flipped since then we would find a monochromatic red triangle while a flip leads to another valid regular edge labeling.
Hence, <span style="font-style:italic">w</span> is still on the bottom path through <span style="font-style:italic">v</span> and still can not be the handle of a large topfan.
</p><p><br>

</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
[t]0.9 @percent
<img src="thesis057.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 42: The regular topfan flip.</td></tr>
</table></div>
<a id="fig:fanflip:regular"></a>

 
[t]0.45 @percent
<img src="thesis058.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 43: Topfan flip above a merge.</td></tr>
</table></div>
<a id="fig:fanflip:merge"></a>

 
[t]0.45 @percent
<img src="thesis059.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 44: Topfan flip next to merge. Note the additional red edge.</td></tr>
</table></div>
<a id="fig:fanflip:mergeLastVertex"></a>

[t]0.45 @percent
<img src="thesis060.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 45: Before a split we stop.</td></tr>
</table></div>
<a id="fig:fanflip:split"></a>

 
[t]0.45 @percent
<img src="thesis061.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 46: If the split is on the first vertex we do not flip at all.</td></tr>
</table></div>
<a id="fig:fanflip:splitFirstVertex"></a>
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 47: Topfan Flips.</td></tr>
</table></div><p>
<a id="fig:fanflip:fanflips"></a>
</p><div class="center"><hr style="width:80%;height:2"></div></div></blockquote>
<!--TOC subsection id="sec17" Topfan flips-->
<h3 id="sec17" class="subsection">5.4  Topfan flips</h3><!--SEC END --><p>

<a id="ss:fanflip"></a></p><p><span style="font-weight:bold">Overview.</span>
In Section <a href="#ss%3AflipBlueZ">??</a>, we obtained a vertically one-sided regular edge labeling (Lemma <a href="#lm%3Asweep%3AvertOnsided">??</a>), moreover, this regular edge labeling never has a split vertex next to a topfan handle along a bottom path (Lemma <a href="#lm%3Azflip%3ANoTwoSplitsAboveEachOtherVertOnesided">??</a>).
Using local recoloring (<em>flips</em>) on the topfans we will maintain a one-sided regular edge labeling (Lemma <a href="#lm%3Atopfan%3AoneSidedREL">??</a>) and make sure that large topfans only occur in very specific situations (Lemma <a href="#lm%3Atopfan%3AremainingTopfans">??</a>). It will turn out that we can deal with these specific situations in the final step of the algorithm described in Section <a href="#ss%3Asubdiv">??</a>.
Our flips differ depending on whether we encounter a split and or merge in the bottom boundary path.
Refer to Figure <a href="#fig%3Afanflip%3Afanflips">??</a> for a first glance at the different kinds of topfan flips.</p><p><span style="font-weight:bold">In what order do we flip topfans.</span>
We would like to start at the bottommost face <span style="font-style:italic">F</span>. We can unfortunately no longer use the creation order since the removal of blue <span style="font-style:italic">Z</span>’s may have changed which faces lie above which other faces, they may even have merged faces.
Hence, we have to show that there always is a face <span style="font-style:italic">F</span> whose whole top boundary path borders faces that are not treated while its bottom boundary path borders no such faces.</p><div class="theorem"><span style="font-weight:bold">Lemma 22</span>  <em>
</em><a id="lm:top:order"></a><em>
There is a face </em><span style="font-style:italic">F</span><em> such that the whole top boundary path of </em><span style="font-style:italic">F</span><em> borders faces that are not treated while the bottom boundary path does not border such faces.
</em></div><p><span style="font-weight:bold">Proof.</span>
Let us first remove all treated faces from Ḡ by removing their blue edges and connecting their red edges with <span style="font-style:italic">S</span>.</p><p>Unless there are no faces remaining, and in that case we are finished, there is at least one <em>splitvertex</em> (vertex with at least two outgoing blue edges) and one <em>merge vertex</em> (vertex with at least two blue incoming edge) along the directed path formed by the vertices adjacent to <span style="font-style:italic">S</span>.
There can be no merges before the first split, nor splits after the last merge. Because there is nowhere for these blue paths to come from or go, respectively.
Hence, somewhere along the path there is a split followed by a merge.
This face has a bottom boundary path that is entirely adjacent to <span style="font-style:italic">S</span> after removing treated faces.
The top boundary path borders untreated faces.
</p><p><br>
</p><p>We keep considering the bottommost untreated face, until ther are no faces left. We know that this face is below only untreated face by Lemma <a href="#lm%3Atop%3Aorder">??</a>. Since a topfan flip only affects the current face and faces below it we never have to flip in a face that is affected by the results of a topfan flip.</p><p>We do not flip topfans whose fanhandle is adjacent to the merge of the face.</p><p><span style="font-weight:bold">How to flip a topfan.</span>
A topfan is above a number of edges of the bottom boundary path of the blue face containing the topfan. These edges are the rim of the fan. We will call a vertex <span style="font-style:italic">S</span><em>-adjacent</em> if it adjacent to <span style="font-style:italic">S</span>.</p><p>We flip the edges of the topfan along the rim starting at the first vertex and ending at the vertex <span style="font-weight:bold">before</span> the first splitvertex or <span style="font-style:italic">S</span>-adjacent vertex or the vertex <span style="font-weight:bold">before</span> the last vertex. This can imply that we do not flip any edges (in the case that the first vertex is a split vertex or <span style="font-style:italic">S</span>-adjacent).</p><p>We will use the notation introduced in figure <a href="#fig%3Afanflip%3Aregular">??</a>.
For the first vertex <span style="font-style:italic">v</span><sub>1</sub> we recolor the adjacent outer edge of the topfan. For subsequent vertices <span style="font-style:italic">v</span><sub><span style="font-style:italic">i</span></sub> we recolor the rim edge between this vertex and the previous vertex <span style="font-style:italic">v</span><sub><span style="font-style:italic">i</span>−1</sub> red and we recolor both edges directly adjacent to this edge in the angular order of <span style="font-style:italic">v</span><sub><span style="font-style:italic">i</span></sub> blue (if they were not already blue).
If we stop flipping before a merge vertex <span style="font-style:italic">v</span><sub><span style="font-style:italic">i</span>+1</sub> we flip an additional edge <span style="font-style:italic">v</span><sub><span style="font-style:italic">i</span></sub> <span style="font-style:italic">v</span><sub><span style="font-style:italic">i</span>+1</sub> along the rim, in order to prevent a blue <span style="font-style:italic">Z</span> from forming.</p><p><span style="font-weight:bold">Examples.</span>
Let us show a few examples of this procedure to improve clarity.
If the rim has no merges or splits, we execute the topfan flip depicted in Figure <a href="#fig%3Afanflip%3Aregular">??</a>.
We color all but the rightmost fan edge blue, color all but the rightmost rim edge red and color the left outer edges of all topfans below this topfan in the face below the current face blue.</p><p>If the rim consists of merges and regular vertices, we easily adept a topfan flip to this situation. We simply do not flip the edge merging in as depicted in Figure <a href="#fig%3Afanflip%3Amerge">??</a>.
A special case is given by a merge on the last vertex on the bottom edges of the topfan. In that case we flip all rim edges (even the last one) to prevent a blue <span style="font-style:italic">Z</span> from forming. See figure <a href="#fig%3Afanflip%3AmergeLastVertex">??</a>.</p><p>Splits are more difficult to handle. We are unfortunately unable to keep flipping once we hit a split hence we stop before we get that far. See Figure <a href="#fig%3Afanflip%3Asplit">??</a>. It this happens on the first vertex we do not flip at all, see Figure <a href="#fig%3Afanflip%3AsplitFirstVertex">??</a>.</p><p><span style="font-weight:bold">The result.</span>
Before the topfanflips, we had a vertically one-sided regular edge labeling. Afterwards we still have a vertically one-sided regular edge labeling, as we will prove in Lemma <a href="#lm%3Atopfan%3AoneSidedREL">??</a>. Moreover, we have no large top-fans except for some controlled cases (Lemma <a href="#lm%3Atopfan%3AremainingTopfans">??</a>).</p><div class="theorem"><span style="font-weight:bold">Lemma 23</span>  <em>
</em><a id="lm:topfan:oneSidedREL"></a><em>
The regular edge labeling is still vertically one-sided after a topfan flip.
</em></div><p><span style="font-weight:bold">Proof.</span>
We take another look at Figure <a href="#fig%3Afanflip%3Afanflips">??</a>. Note that due to Lemma <a href="#lm%3Azflip%3AblueZNorVertOneSided">??</a> a regular edge labeling is vertically one-sided as long as there is no blue <span style="font-style:italic">Z</span>. Since the graph was one-sided we can assume that we had no blue <span style="font-style:italic">Z</span>’s.
Let us first consider the regular case. Since the edge <span style="font-style:italic">v</span><sub><span style="font-style:italic">n</span></sub> <span style="font-style:italic">w</span><sub><span style="font-style:italic">m</span></sub> is red, (otherwise we would have a merge) this change does not produce any blue <span style="font-style:italic">Z</span>’s.</p><p>The merge case, due to the clever recoloring, also does not lead to a blue <span style="font-style:italic">Z</span>.
It is clear the split cases do not produce a blue <span style="font-style:italic">Z</span> either.
Since any <span style="font-style:italic">S</span>-adjacent fan is treated like a split fan, we also do not create <span style="font-style:italic">Z</span>’s in these cases.
</p><p><br>

</p><div class="theorem"><span style="font-weight:bold">Lemma 24</span>  <em>
</em><a id="lm:topfan:remainingTopfans"></a><em>
In the remaining faces every large topfan is in one of the following two situations:
</em><ol class="enumerate" type=1><li class="li-enumerate"><em>
</em><em>This topfan is at the start of the face.
</em></li><li class="li-enumerate"><em>The left outer rim vertex is a splitvertex.
</em></li></ol><em>
</em></div><p><span style="font-weight:bold">Proof.</span>
All topfans are manipulated in such a way that they start a new face, or are colored blue entirely, unless the left outer rim vertex is a split. Since in that case we do not flip at all, but then the left outer rim vertex is indeed a split.
</p><p><br>

</p>
<!--TOC subsection id="sec18" Blue face subdivision-->
<h3 id="sec18" class="subsection">5.5  Blue face subdivision</h3><!--SEC END --><p>

<a id="ss:subdiv"></a>
At this point we have a vertically one-sided graph (due to Lemma <a href="#lm%3Atopfan%3AoneSidedREL">??</a>) without large topfans except for the locations provided in Lemma <a href="#lm%3Atopfan%3AremainingTopfans">??</a>.
In this section we are going to recolor edges in blue faces to make all of them <span style="font-style:italic">d</span>−1-sided, while at the same time not recoloring so many edges above each other that we create a large red face.</p><p>We would like to start at the bottommost face <span style="font-style:italic">F</span>. Due to Lemma <a href="#lm%3Atop%3Aorder">??</a> we know that there is always a face whose whole top boundary path of borders faces that are not treated while no part of the bottom boundary path borders such faces.</p><p>We now recolor some of the edges of this face if it is too large.
We then mark the edges on the top boundary path of this face above the recolored edges as <em>loaded</em>.
We try to avoid flipping above these edges in future iterations of the algorithm.
Then we continue with the next face in the creation order.</p><p><span style="font-weight:bold">Loads.</span>
As is mentioned above we mark some edges with so-called <em>loads</em>, we refer to these edges as <em>loaded</em> in the rest of the section.
The exact use of these loaded edges becomes clear in the rest of this section.</p><p>It is important to note that if we load any blue edge we regard any other blue edge sharing at least one vertex with this edge to be loaded as well.
The occurrence of this phenomenon is called <em>putting through a load</em>.
An example can be seen in Figure <a href="#fig%3Asubdiv%3AputTrougLoad">??</a> where we flipped the thick edge, and hence marked <span style="font-style:italic">uv</span> as loaded and because of putting through load also marked <span style="font-style:italic">uw</span> as loaded.</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
<img src="thesis062.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 48: Putting through load.</td></tr>
</table></div>
<a id="fig:subdiv:putTrougLoad"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><p><span style="font-weight:bold">Step requirements.</span>
We flip edges in each face, taking into account loads on the bottom boundary path, such that:</p><ol class="enumerate" type=1><li class="li-enumerate">
We never load the two edges next to a split or merge vertex on the top boundary path.
</li><li class="li-enumerate">We never load two adjacent edges on the top boundary path.
</li></ol><p>If we flip edges in line with the step requirements for every face then the following lemma holds for the bottom boundary path of yet untreated faces.</p><div class="theorem"><span style="font-weight:bold">Lemma 25</span>  <em>
</em><a id="lm:"></a><em>
On the bottom boundary path of a face we never find two subsequent loaded edges. Even when we put through loads on splits and merges.
</em></div><p><span style="font-weight:bold">Proof.</span>
A single face would never load two subsequent edges. Hence, the only way to get two subsequent loaded edges is using different faces and thus splits and merges.
However, due to never flipping the two edges next to a split or merge we neither get subsequent loaded edges in such a case.
</p><p><br>
</p>
<!--TOC subsubsection id="sec19" Faces without large topfans in the middle-->
<h4 id="sec19" class="subsubsection">5.5.1  Faces without large topfans in the middle</h4><!--SEC END --><div class="theorem"><span style="font-weight:bold">Lemma 26</span>  <em>
</em><a id="lm:subdiv:withoutTopfan"></a><em>
We can subdivide any blue face without large topfans into </em><span style="font-style:italic">d</span>−1<em>-sided chunks while obeying the load rules above.
</em></div><p><span style="font-weight:bold">Proof.</span>
A worst case example is given in Figure <a href="#fig%3Asubdiv%3AworstCaseWithTopFan">??</a>.
Note that we can flip to the right edge above each edge in the bottom boundary path except if we would end up next to the merge.
In that case we flip the left edge above this edge.</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
<img src="thesis063.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 49: A worst case blue face. We do not flip any edge in this face.</td></tr>
</table></div>
<a id="fig:subdiv:worstCaseWithTopFan"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><p>We look at the vertex on the bottom fence that is incident to the freshly flipped edge, or if we have not flipped an edge yet the vertex next to the split (and we denote it by <span style="font-style:italic">v</span>). The following are then the rules for flipping above the edges following <span style="font-style:italic">v</span>.
</p><ol class="enumerate" type=1><li class="li-enumerate">
We do not flip above the edges of the first topfan.
</li><li class="li-enumerate">We flip above the second edge if it is unloaded.
</li><li class="li-enumerate">Otherwise, we flip above the third edge.
</li><li class="li-enumerate">We never flip next to the merge.
</li></ol><p>When flipping above an edge, we always flip the right edge above that edge. Unless we are on the edge next to the merge, because then we flip the left edge above that edge.</p><p>The first edge give us the required separation of loaded edges along the top boundary path. The other items make sure we obey the other rules.</p><p>The worst case is given by a large topfan at the start and a combination of the last two items. We would in that case want to flip above the second-to-last edge of the bottom boundary path. But we do not because the next edge is incident to the merge vertex. This gives at worst a topfan and two more edges along the bottom boundary path and hence a  <span style="font-style:italic">d</span> − 3 +2 = <span style="font-style:italic">d</span> −1-sided face.
</p><p><br>
</p><p>See Figure <a href="#fig%3Asubdiv%3AsampleExecution">??</a> for a sample execution of the algorithm described in Lemma <a href="#lm%3Asubdiv%3AwithoutTopfan">??</a>.</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
<img src="thesis064.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 50: Sample execution of the algorithm.</td></tr>
</table></div>
<a id="fig:subdiv:sampleExecution"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote>
<!--TOC subsubsection id="sec20" Face encountering a larger topfan-->
<h4 id="sec20" class="subsubsection">5.5.2  Face encountering a larger topfan</h4><!--SEC END --><p>
If we have a large topfan in the middle of the face then above the left outer edge of this topfan we can not have another topfan that failed to flip its left outer edges due to Lemma <a href="#lm%3Azflip%3ANoTwoSplitsAboveEachOtherVertOnesided">??</a>.
This means we can use the following rule: we flip the first edge of a topfan even above a loaded edge.
We call such flip a <em>forced</em> flip.</p><p>We can not have two such forced flips above each other because that would give a situation as in Figure <a href="#fig%3Asubdiv%3AforcedFlips">??</a>.
However, that would mean the fan with fanhandle <span style="font-style:italic">u</span> must be the handle of a topfan that failed its flip and hence <span style="font-style:italic">v</span> must have been a split vertex. But then by Lemma <a href="#lm%3Azflip%3ANoTwoSplitsAboveEachOtherVertOnesided">??</a> <span style="font-style:italic">w</span> can not be the handle of a large topfan.</p><blockquote class="figure"><div class="center"><div class="center"><hr style="width:80%;height:2"></div>
<img src="thesis065.png">
<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Figure 51: Two forced flips above each other.</td></tr>
</table></div>
<a id="fig:subdiv:forcedFlips"></a>
<div class="center"><hr style="width:80%;height:2"></div></div></blockquote><p>Since we do not allow a flip above a load (whether it was forced or not) this means that the worst thing that can happen is an ordinary flip followed by a <em>forced</em> flip. These two flips can not be followed by any other flip. Hence, the worst case only makes chains of at most 2 blue <span style="font-style:italic">Z</span>’s, that is, a blue path of length 5.</p>
<!--TOC subsubsection id="sec21" Conclusion-->
<h4 id="sec21" class="subsubsection">5.5.3  Conclusion</h4><!--SEC END --><p>
This concludes the last step of the algorithm.
Now all the steps in the algorithm are done all that is left is to show that we indeed generated a <span style="font-style:italic">d</span>−1-sided regular edge labeling.
</p><div class="theorem"><span style="font-weight:bold">Lemma 27</span>  <em>
</em><a id="lm:subdiv:2chaindedZ"></a><em>
Two blue flips above each other give at worst a red </em><span style="font-style:italic">d</span>−1<em>-sided face
</em></div><p><span style="font-weight:bold">Proof.</span>
With a <em>blue fan</em> we mean a vertex that has multiple incoming or outgoing blue edges on the interior of this red face.
The two blue flips above each other give a blue path <span style="color:red"><span style="font-style:italic">P</span></span> of length 5 inside a red face.</p><p>Before creating the <span style="font-style:italic">Z</span>’s in this section, the regular edge labeling was vertically one-sided.
That is, before recoloring the two edges in this section there were no paths of length 3 inside the face.
This also implies that any <span style="font-style:italic">Z</span> we now create can have at most one blue fan on the top and one blue fan on the bottom, otherwise we would already have had a 3-path.</p><p>So for two <span style="font-style:italic">Z</span>’s we have at most three blue fans.
Hence, on one side we have at most one of these.
Then the boundary path at this side of the face has at most <span style="font-style:italic">d</span>−3 + 1 +1 =<span style="font-style:italic">d</span>−1 vertices not counting the split and merge vertex of the red face.
</p><p><br>
</p><p>Then we can now prove Theorem <a href="#th%3Adsided">??</a>.</p><p><span style="font-weight:bold">Proof.</span>[Proof of Theorem <a href="#th%3Adsided">??</a> ]
By construction all blue faces are <span style="font-style:italic">d</span>−1-sided. We have at most two blue flips above each other so red faces are <span style="font-style:italic">d</span>−1-sided by Lemma <a href="#lm%3Asubdiv%3A2chaindedZ">??</a>. Hence, we have a <span style="font-style:italic">d</span>−1-sided rectangular edge labeling of Ḡ corresponding to a <span style="font-style:italic">d</span>-sided rectangular dual of Ḡ
</p><p><br>

</p>
<!--TOC section id="sec22" Conclusions and future work-->
<h2 id="sec22" class="section">6  Conclusions and future work</h2><!--SEC END --><p><span style="font-weight:bold">Results.</span>
In this thesis we proved the following two theorems</p><ol class="enumerate" type=1><li class="li-enumerate">
There is a family of graphs <span style="font-style:italic">G</span><sub><span style="font-style:italic">k</span></sub> that for any <span style="font-style:italic">k</span> ∈ ℕ has members that are not <span style="font-style:italic">k</span>-sided (Theorem <a href="#fix%3Ath%3Afamily">??</a>).
</li><li class="li-enumerate">Graphs <span style="font-style:italic">G</span> that have a corner assignment without separating 4-cycles are <span style="font-style:italic">d</span>−1-sided, where <span style="font-style:italic">d</span> is the maximal degree of the vertices of <span style="font-style:italic">G</span> in Ḡ. (Theorem <a href="#th%3Adsided">??</a>)
</li></ol><p><span style="font-weight:bold">Open Questions.</span>
There are many remaining open problems.
One might, for example, hope to show that all corner assignments without separating 4-cycles admit a 2-sided rectangular layout. Failing this, a proof these corner assignments, or their underlying graphs, have a <span style="font-style:italic">k</span>-sided layout for any constant <span style="font-style:italic">k</span>∈ ℕ would already be nice.</p><p>Another challenging problem is finding an algorithm that has traction on graphs containing (nested) separating 4-cycles.
For these graphs there might be an algorithm that gives a <span style="font-style:italic">d</span>-sided layout, since the family of graphs provided in the proof of Theorem <a href="#fix%3Ath%3Afamily">??</a> has unbounded maximal degree.
However, Theorem <a href="#fix%3Ath%3Afamily">??</a> prevent us from finding an algorithm generating a <span style="font-style:italic">k</span>-sided layout for all graphs admitting a rectangular layout, for any constant <span style="font-style:italic">k</span>.</p><p>I also wonder whether the second step in our algorithm, Flipping blue <span style="font-style:italic">Z</span>’s, is necessary.
Since I suspect that result of the sweepcycle algorithm in the first step is vertically one-sided.</p><p><span style="font-weight:bold">Sweepcycle algorithms.</span>
I feel the full potential of sweepcycle algorithms is not yet unlocked in this work and the work by Fusy [<a href="#Fusy2006"></a>].
Since the current algorithm needs many steps to be able to repair those blue faces that are too large, it might be beneficial to concentrate more on the shape of the blue faces, the horizontal segments in the rectangular dual, in the initial sweepcycle algorithm.</p><p>One might try to build a better sweepcycle algorithm by directly finding blue faces with short enough boundary paths, hopefully without creating large red faces during its execution by choosing the right invariants.
To obtain these invariants one could try to first find a sweepcycle algorithm that provides a regular edge labeling that is horizontally, instead of vertically, one-sided (or horizontally <span style="font-style:italic">k</span>-sided while maintaining reasonable vertical segments).
This way an algorithm obtaining a <span style="font-style:italic">k</span>-sided layout, for some constant <span style="font-style:italic">k</span> ∈ ℕ, for any corner assignment without separating 4-cycles may be possible.</p><p>Another approach would be to update the sweepcycle with paths that are not entirely blue (horizontal segments in an dual), but partially blue and partially red (corners in a rectangular dual).</p><p>On the other hand, there is also an unexplored world of algorithms working directly on the rectangular dual. Maybe some cross-pollination between such an algorithm and an algorithm manipulating a regular edge labeling will lead to success.</p><!--TOC section id="sec23" Acknowledgments-->
<h2 id="sec23" class="section">Acknowledgments</h2><!--SEC END --><p>
I would not have been able to write this thesis without my two daily supervisors Bettina Speckmann and Kevin Verbeek. They always provided suggestions and motivation when I was stuck and helped bring structure in the mess that this thesis first was. I also want to thank Jesper Nederlof and
Rudi Pendavingh for making this project possible by guaranteeing that it is sufficiently mathematical.
Moreover, I want to thank Wouter Ligtenberg and Hans Beekhuis for reading through my thesis and finding many mistakes. Last but not least I would like to thank Kaylee, my friends and my family for being a outlet for my frustrations and sharing my joys.
</p><p>1em
</p><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<hr style="height:2"><blockquote class="quote"><em>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</em><a href="http://hevea.inria.fr/index.html"><em>H</em><em><span style="font-size:small"><sup>E</sup></span></em><em>V</em><em><span style="font-size:small"><sup>E</sup></span></em><em>A</em></a><em>.</em></blockquote></body>
</html>
